/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2019, assimp team



All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// The Open-Asset-Importer-Lib
class LibAssimp {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibAssimp(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibAssimp.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Float> _ai_epsilon =
      _lookup<ffi.Float>('ai_epsilon');

  double get ai_epsilon => _ai_epsilon.value;

  set ai_epsilon(double value) => _ai_epsilon.value = value;

  late final ffi.Pointer<ffi.Int32> _signgam = _lookup<ffi.Int32>('signgam');

  int get signgam => _signgam.value;

  set signgam(int value) => _signgam.value = value;

  /// Returns the number of export file formats available in the current Assimp build.
  /// Use aiGetExportFormatDescription() to retrieve infos of a specific export format.
  int aiGetExportFormatCount() {
    return _aiGetExportFormatCount();
  }

  late final _aiGetExportFormatCount_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetExportFormatCount>>(
          'aiGetExportFormatCount');
  late final _dart_aiGetExportFormatCount _aiGetExportFormatCount =
      _aiGetExportFormatCount_ptr.asFunction<_dart_aiGetExportFormatCount>();

  /// Returns a description of the nth export file format. Use #aiGetExportFormatCount()
  /// to learn how many export formats are supported. The description must be released by
  /// calling aiReleaseExportFormatDescription afterwards.
  /// @param pIndex Index of the export format to retrieve information for. Valid range is
  /// 0 to #aiGetExportFormatCount()
  /// @return A description of that specific export format. NULL if pIndex is out of range.
  ffi.Pointer<aiExportFormatDesc> aiGetExportFormatDescription(
    int pIndex,
  ) {
    return _aiGetExportFormatDescription(
      pIndex,
    );
  }

  late final _aiGetExportFormatDescription_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetExportFormatDescription>>(
          'aiGetExportFormatDescription');
  late final _dart_aiGetExportFormatDescription _aiGetExportFormatDescription =
      _aiGetExportFormatDescription_ptr
          .asFunction<_dart_aiGetExportFormatDescription>();

  /// Release a description of the nth export file format. Must be returned by
  /// aiGetExportFormatDescription
  /// @param desc Pointer to the description
  void aiReleaseExportFormatDescription(
    ffi.Pointer<aiExportFormatDesc> desc,
  ) {
    return _aiReleaseExportFormatDescription(
      desc,
    );
  }

  late final _aiReleaseExportFormatDescription_ptr =
      _lookup<ffi.NativeFunction<_c_aiReleaseExportFormatDescription>>(
          'aiReleaseExportFormatDescription');
  late final _dart_aiReleaseExportFormatDescription
      _aiReleaseExportFormatDescription = _aiReleaseExportFormatDescription_ptr
          .asFunction<_dart_aiReleaseExportFormatDescription>();

  /// Create a modifiable copy of a scene.
  /// This is useful to import files via Assimp, change their topology and
  /// export them again. Since the scene returned by the various importer functions
  /// is const, a modifiable copy is needed.
  /// @param pIn Valid scene to be copied
  /// @param pOut Receives a modifyable copy of the scene. Use aiFreeScene() to
  /// delete it again.
  void aiCopyScene(
    ffi.Pointer<aiScene> pIn,
    ffi.Pointer<ffi.Pointer<aiScene>> pOut,
  ) {
    return _aiCopyScene(
      pIn,
      pOut,
    );
  }

  late final _aiCopyScene_ptr =
      _lookup<ffi.NativeFunction<_c_aiCopyScene>>('aiCopyScene');
  late final _dart_aiCopyScene _aiCopyScene =
      _aiCopyScene_ptr.asFunction<_dart_aiCopyScene>();

  /// Frees a scene copy created using aiCopyScene()
  void aiFreeScene(
    ffi.Pointer<aiScene> pIn,
  ) {
    return _aiFreeScene(
      pIn,
    );
  }

  late final _aiFreeScene_ptr =
      _lookup<ffi.NativeFunction<_c_aiFreeScene>>('aiFreeScene');
  late final _dart_aiFreeScene _aiFreeScene =
      _aiFreeScene_ptr.asFunction<_dart_aiFreeScene>();

  /// Exports the given scene to a chosen file format and writes the result file(s) to disk.
  /// @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
  /// The scene is expected to conform to Assimp's Importer output format as specified
  /// in the @link data Data Structures Page @endlink. In short, this means the model data
  /// should use a right-handed coordinate systems, face winding should be counter-clockwise
  /// and the UV coordinate origin is assumed to be in the upper left. If your input data
  /// uses different conventions, have a look at the last parameter.
  /// @param pFormatId ID string to specify to which format you want to export to. Use
  /// aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.
  /// @param pFileName Output file to write
  /// @param pPreprocessing Accepts any choice of the #aiPostProcessSteps enumerated
  /// flags, but in reality only a subset of them makes sense here. Specifying
  /// 'preprocessing' flags is useful if the input scene does not conform to
  /// Assimp's default conventions as specified in the @link data Data Structures Page @endlink.
  /// In short, this means the geometry data should use a right-handed coordinate systems, face
  /// winding should be counter-clockwise and the UV coordinate origin is assumed to be in
  /// the upper left. The #aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and
  /// #aiProcess_FlipWindingOrder flags are used in the import side to allow users
  /// to have those defaults automatically adapted to their conventions. Specifying those flags
  /// for exporting has the opposite effect, respectively. Some other of the
  /// #aiPostProcessSteps enumerated values may be useful as well, but you'll need
  /// to try out what their effect on the exported file is. Many formats impose
  /// their own restrictions on the structure of the geometry stored therein,
  /// so some preprocessing may have little or no effect at all, or may be
  /// redundant as exporters would apply them anyhow. A good example
  /// is triangulation - whilst you can enforce it by specifying
  /// the #aiProcess_Triangulate flag, most export formats support only
  /// triangulate data so they would run the step anyway.
  ///
  /// If assimp detects that the input scene was directly taken from the importer side of
  /// the library (i.e. not copied using aiCopyScene and potetially modified afterwards),
  /// any postprocessing steps already applied to the scene will not be applied again, unless
  /// they show non-idempotent behaviour (#aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and
  /// #aiProcess_FlipWindingOrder).
  /// @return a status code indicating the result of the export
  /// @note Use aiCopyScene() to get a modifiable copy of a previously
  /// imported scene.
  int aiExportScene(
    ffi.Pointer<aiScene> pScene,
    ffi.Pointer<ffi.Int8> pFormatId,
    ffi.Pointer<ffi.Int8> pFileName,
    int pPreprocessing,
  ) {
    return _aiExportScene(
      pScene,
      pFormatId,
      pFileName,
      pPreprocessing,
    );
  }

  late final _aiExportScene_ptr =
      _lookup<ffi.NativeFunction<_c_aiExportScene>>('aiExportScene');
  late final _dart_aiExportScene _aiExportScene =
      _aiExportScene_ptr.asFunction<_dart_aiExportScene>();

  /// Exports the given scene to a chosen file format using custom IO logic supplied by you.
  /// @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
  /// @param pFormatId ID string to specify to which format you want to export to. Use
  /// aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.
  /// @param pFileName Output file to write
  /// @param pIO custom IO implementation to be used. Use this if you use your own storage methods.
  /// If none is supplied, a default implementation using standard file IO is used. Note that
  /// #aiExportSceneToBlob is provided as convenience function to export to memory buffers.
  /// @param pPreprocessing Please see the documentation for #aiExportScene
  /// @return a status code indicating the result of the export
  /// @note Include <aiFileIO.h> for the definition of #aiFileIO.
  /// @note Use aiCopyScene() to get a modifiable copy of a previously
  /// imported scene.
  int aiExportSceneEx(
    ffi.Pointer<aiScene> pScene,
    ffi.Pointer<ffi.Int8> pFormatId,
    ffi.Pointer<ffi.Int8> pFileName,
    ffi.Pointer<aiFileIO> pIO,
    int pPreprocessing,
  ) {
    return _aiExportSceneEx(
      pScene,
      pFormatId,
      pFileName,
      pIO,
      pPreprocessing,
    );
  }

  late final _aiExportSceneEx_ptr =
      _lookup<ffi.NativeFunction<_c_aiExportSceneEx>>('aiExportSceneEx');
  late final _dart_aiExportSceneEx _aiExportSceneEx =
      _aiExportSceneEx_ptr.asFunction<_dart_aiExportSceneEx>();

  /// Exports the given scene to a chosen file format. Returns the exported data as a binary blob which
  /// you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()
  /// to free the resources associated with the export.
  /// @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
  /// @param pFormatId ID string to specify to which format you want to export to. Use
  /// #aiGetExportFormatCount() / #aiGetExportFormatDescription() to learn which export formats are available.
  /// @param pPreprocessing Please see the documentation for #aiExportScene
  /// @return the exported data or NULL in case of error
  ffi.Pointer<aiExportDataBlob> aiExportSceneToBlob(
    ffi.Pointer<aiScene> pScene,
    ffi.Pointer<ffi.Int8> pFormatId,
    int pPreprocessing,
  ) {
    return _aiExportSceneToBlob(
      pScene,
      pFormatId,
      pPreprocessing,
    );
  }

  late final _aiExportSceneToBlob_ptr =
      _lookup<ffi.NativeFunction<_c_aiExportSceneToBlob>>(
          'aiExportSceneToBlob');
  late final _dart_aiExportSceneToBlob _aiExportSceneToBlob =
      _aiExportSceneToBlob_ptr.asFunction<_dart_aiExportSceneToBlob>();

  /// Releases the memory associated with the given exported data. Use this function to free a data blob
  /// returned by aiExportScene().
  /// @param pData the data blob returned by #aiExportSceneToBlob
  void aiReleaseExportBlob(
    ffi.Pointer<aiExportDataBlob> pData,
  ) {
    return _aiReleaseExportBlob(
      pData,
    );
  }

  late final _aiReleaseExportBlob_ptr =
      _lookup<ffi.NativeFunction<_c_aiReleaseExportBlob>>(
          'aiReleaseExportBlob');
  late final _dart_aiReleaseExportBlob _aiReleaseExportBlob =
      _aiReleaseExportBlob_ptr.asFunction<_dart_aiReleaseExportBlob>();

  /// \brief  Returns the Importer description for a given extension.
  ///
  /// Will return a NULL-pointer if no assigned importer desc. was found for the given extension
  /// \param  extension   [in] The extension to look for
  /// \return A pointer showing to the ImporterDesc, \see aiImporterDesc.
  ffi.Pointer<aiImporterDesc> aiGetImporterDesc(
    ffi.Pointer<ffi.Int8> extension_1,
  ) {
    return _aiGetImporterDesc(
      extension_1,
    );
  }

  late final _aiGetImporterDesc_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetImporterDesc>>('aiGetImporterDesc');
  late final _dart_aiGetImporterDesc _aiGetImporterDesc =
      _aiGetImporterDesc_ptr.asFunction<_dart_aiGetImporterDesc>();

  /// Reads the given file and returns its content.
  ///
  /// If the call succeeds, the imported data is returned in an aiScene structure.
  /// The data is intended to be read-only, it stays property of the ASSIMP
  /// library and will be stable until aiReleaseImport() is called. After you're
  /// done with it, call aiReleaseImport() to free the resources associated with
  /// this file. If the import fails, NULL is returned instead. Call
  /// aiGetErrorString() to retrieve a human-readable error text.
  /// @param pFile Path and filename of the file to be imported,
  /// expected to be a null-terminated c-string. NULL is not a valid value.
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags.
  /// @return Pointer to the imported data or NULL if the import failed.
  ffi.Pointer<aiScene> aiImportFile(
    ffi.Pointer<ffi.Int8> pFile,
    int pFlags,
  ) {
    return _aiImportFile(
      pFile,
      pFlags,
    );
  }

  late final _aiImportFile_ptr =
      _lookup<ffi.NativeFunction<_c_aiImportFile>>('aiImportFile');
  late final _dart_aiImportFile _aiImportFile =
      _aiImportFile_ptr.asFunction<_dart_aiImportFile>();

  /// Reads the given file using user-defined I/O functions and returns
  /// its content.
  ///
  /// If the call succeeds, the imported data is returned in an aiScene structure.
  /// The data is intended to be read-only, it stays property of the ASSIMP
  /// library and will be stable until aiReleaseImport() is called. After you're
  /// done with it, call aiReleaseImport() to free the resources associated with
  /// this file. If the import fails, NULL is returned instead. Call
  /// aiGetErrorString() to retrieve a human-readable error text.
  /// @param pFile Path and filename of the file to be imported,
  /// expected to be a null-terminated c-string. NULL is not a valid value.
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags.
  /// @param pFS aiFileIO structure. Will be used to open the model file itself
  /// and any other files the loader needs to open.  Pass NULL to use the default
  /// implementation.
  /// @return Pointer to the imported data or NULL if the import failed.
  /// @note Include <aiFileIO.h> for the definition of #aiFileIO.
  ffi.Pointer<aiScene> aiImportFileEx(
    ffi.Pointer<ffi.Int8> pFile,
    int pFlags,
    ffi.Pointer<aiFileIO> pFS,
  ) {
    return _aiImportFileEx(
      pFile,
      pFlags,
      pFS,
    );
  }

  late final _aiImportFileEx_ptr =
      _lookup<ffi.NativeFunction<_c_aiImportFileEx>>('aiImportFileEx');
  late final _dart_aiImportFileEx _aiImportFileEx =
      _aiImportFileEx_ptr.asFunction<_dart_aiImportFileEx>();

  /// Same as #aiImportFileEx, but adds an extra parameter containing importer settings.
  ///
  /// @param pFile Path and filename of the file to be imported,
  /// expected to be a null-terminated c-string. NULL is not a valid value.
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags.
  /// @param pFS aiFileIO structure. Will be used to open the model file itself
  /// and any other files the loader needs to open.  Pass NULL to use the default
  /// implementation.
  /// @param pProps #aiPropertyStore instance containing import settings.
  /// @return Pointer to the imported data or NULL if the import failed.
  /// @note Include <aiFileIO.h> for the definition of #aiFileIO.
  /// @see aiImportFileEx
  ffi.Pointer<aiScene> aiImportFileExWithProperties(
    ffi.Pointer<ffi.Int8> pFile,
    int pFlags,
    ffi.Pointer<aiFileIO> pFS,
    ffi.Pointer<aiPropertyStore> pProps,
  ) {
    return _aiImportFileExWithProperties(
      pFile,
      pFlags,
      pFS,
      pProps,
    );
  }

  late final _aiImportFileExWithProperties_ptr =
      _lookup<ffi.NativeFunction<_c_aiImportFileExWithProperties>>(
          'aiImportFileExWithProperties');
  late final _dart_aiImportFileExWithProperties _aiImportFileExWithProperties =
      _aiImportFileExWithProperties_ptr
          .asFunction<_dart_aiImportFileExWithProperties>();

  /// Reads the given file from a given memory buffer,
  ///
  /// If the call succeeds, the contents of the file are returned as a pointer to an
  /// aiScene object. The returned data is intended to be read-only, the importer keeps
  /// ownership of the data and will destroy it upon destruction. If the import fails,
  /// NULL is returned.
  /// A human-readable error description can be retrieved by calling aiGetErrorString().
  /// @param pBuffer Pointer to the file data
  /// @param pLength Length of pBuffer, in bytes
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags. If you wish to inspect the imported
  /// scene first in order to fine-tune your post-processing setup,
  /// consider to use #aiApplyPostProcessing().
  /// @param pHint An additional hint to the library. If this is a non empty string,
  /// the library looks for a loader to support the file extension specified by pHint
  /// and passes the file to the first matching loader. If this loader is unable to
  /// completely the request, the library continues and tries to determine the file
  /// format on its own, a task that may or may not be successful.
  /// Check the return value, and you'll know ...
  /// @return A pointer to the imported data, NULL if the import failed.
  ///
  /// @note This is a straightforward way to decode models from memory
  /// buffers, but it doesn't handle model formats that spread their
  /// data across multiple files or even directories. Examples include
  /// OBJ or MD3, which outsource parts of their material info into
  /// external scripts. If you need full functionality, provide
  /// a custom IOSystem to make Assimp find these files and use
  /// the regular aiImportFileEx()/aiImportFileExWithProperties() API.
  ffi.Pointer<aiScene> aiImportFileFromMemory(
    ffi.Pointer<ffi.Int8> pBuffer,
    int pLength,
    int pFlags,
    ffi.Pointer<ffi.Int8> pHint,
  ) {
    return _aiImportFileFromMemory(
      pBuffer,
      pLength,
      pFlags,
      pHint,
    );
  }

  late final _aiImportFileFromMemory_ptr =
      _lookup<ffi.NativeFunction<_c_aiImportFileFromMemory>>(
          'aiImportFileFromMemory');
  late final _dart_aiImportFileFromMemory _aiImportFileFromMemory =
      _aiImportFileFromMemory_ptr.asFunction<_dart_aiImportFileFromMemory>();

  /// Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.
  ///
  /// @param pBuffer Pointer to the file data
  /// @param pLength Length of pBuffer, in bytes
  /// @param pFlags Optional post processing steps to be executed after
  /// a successful import. Provide a bitwise combination of the
  /// #aiPostProcessSteps flags. If you wish to inspect the imported
  /// scene first in order to fine-tune your post-processing setup,
  /// consider to use #aiApplyPostProcessing().
  /// @param pHint An additional hint to the library. If this is a non empty string,
  /// the library looks for a loader to support the file extension specified by pHint
  /// and passes the file to the first matching loader. If this loader is unable to
  /// completely the request, the library continues and tries to determine the file
  /// format on its own, a task that may or may not be successful.
  /// Check the return value, and you'll know ...
  /// @param pProps #aiPropertyStore instance containing import settings.
  /// @return A pointer to the imported data, NULL if the import failed.
  ///
  /// @note This is a straightforward way to decode models from memory
  /// buffers, but it doesn't handle model formats that spread their
  /// data across multiple files or even directories. Examples include
  /// OBJ or MD3, which outsource parts of their material info into
  /// external scripts. If you need full functionality, provide
  /// a custom IOSystem to make Assimp find these files and use
  /// the regular aiImportFileEx()/aiImportFileExWithProperties() API.
  /// @see aiImportFileFromMemory
  ffi.Pointer<aiScene> aiImportFileFromMemoryWithProperties(
    ffi.Pointer<ffi.Int8> pBuffer,
    int pLength,
    int pFlags,
    ffi.Pointer<ffi.Int8> pHint,
    ffi.Pointer<aiPropertyStore> pProps,
  ) {
    return _aiImportFileFromMemoryWithProperties(
      pBuffer,
      pLength,
      pFlags,
      pHint,
      pProps,
    );
  }

  late final _aiImportFileFromMemoryWithProperties_ptr =
      _lookup<ffi.NativeFunction<_c_aiImportFileFromMemoryWithProperties>>(
          'aiImportFileFromMemoryWithProperties');
  late final _dart_aiImportFileFromMemoryWithProperties
      _aiImportFileFromMemoryWithProperties =
      _aiImportFileFromMemoryWithProperties_ptr
          .asFunction<_dart_aiImportFileFromMemoryWithProperties>();

  /// Apply post-processing to an already-imported scene.
  ///
  /// This is strictly equivalent to calling #aiImportFile()/#aiImportFileEx with the
  /// same flags. However, you can use this separate function to inspect the imported
  /// scene first to fine-tune your post-processing setup.
  /// @param pScene Scene to work on.
  /// @param pFlags Provide a bitwise combination of the #aiPostProcessSteps flags.
  /// @return A pointer to the post-processed data. Post processing is done in-place,
  /// meaning this is still the same #aiScene which you passed for pScene. However,
  /// _if_ post-processing failed, the scene could now be NULL. That's quite a rare
  /// case, post processing steps are not really designed to 'fail'. To be exact,
  /// the #aiProcess_ValidateDataStructure flag is currently the only post processing step
  /// which can actually cause the scene to be reset to NULL.
  ffi.Pointer<aiScene> aiApplyPostProcessing(
    ffi.Pointer<aiScene> pScene,
    int pFlags,
  ) {
    return _aiApplyPostProcessing(
      pScene,
      pFlags,
    );
  }

  late final _aiApplyPostProcessing_ptr =
      _lookup<ffi.NativeFunction<_c_aiApplyPostProcessing>>(
          'aiApplyPostProcessing');
  late final _dart_aiApplyPostProcessing _aiApplyPostProcessing =
      _aiApplyPostProcessing_ptr.asFunction<_dart_aiApplyPostProcessing>();

  /// Get one of the predefine log streams. This is the quick'n'easy solution to
  /// access Assimp's log system. Attaching a log stream can slightly reduce Assimp's
  /// overall import performance.
  ///
  /// Usage is rather simple (this will stream the log to a file, named log.txt, and
  /// the stdout stream of the process:
  /// @code
  /// struct aiLogStream c;
  /// c = aiGetPredefinedLogStream(aiDefaultLogStream_FILE,"log.txt");
  /// aiAttachLogStream(&c);
  /// c = aiGetPredefinedLogStream(aiDefaultLogStream_STDOUT,NULL);
  /// aiAttachLogStream(&c);
  /// @endcode
  ///
  /// @param pStreams One of the #aiDefaultLogStream enumerated values.
  /// @param file Solely for the #aiDefaultLogStream_FILE flag: specifies the file to write to.
  /// Pass NULL for all other flags.
  /// @return The log stream. callback is set to NULL if something went wrong.
  aiLogStream aiGetPredefinedLogStream(
    int pStreams,
    ffi.Pointer<ffi.Int8> file,
  ) {
    return _aiGetPredefinedLogStream(
      pStreams,
      file,
    );
  }

  late final _aiGetPredefinedLogStream_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetPredefinedLogStream>>(
          'aiGetPredefinedLogStream');
  late final _dart_aiGetPredefinedLogStream _aiGetPredefinedLogStream =
      _aiGetPredefinedLogStream_ptr
          .asFunction<_dart_aiGetPredefinedLogStream>();

  /// Attach a custom log stream to the libraries' logging system.
  ///
  /// Attaching a log stream can slightly reduce Assimp's overall import
  /// performance. Multiple log-streams can be attached.
  /// @param stream Describes the new log stream.
  /// @note To ensure proper destruction of the logging system, you need to manually
  /// call aiDetachLogStream() on every single log stream you attach.
  /// Alternatively (for the lazy folks) #aiDetachAllLogStreams is provided.
  void aiAttachLogStream(
    ffi.Pointer<aiLogStream> stream,
  ) {
    return _aiAttachLogStream(
      stream,
    );
  }

  late final _aiAttachLogStream_ptr =
      _lookup<ffi.NativeFunction<_c_aiAttachLogStream>>('aiAttachLogStream');
  late final _dart_aiAttachLogStream _aiAttachLogStream =
      _aiAttachLogStream_ptr.asFunction<_dart_aiAttachLogStream>();

  /// Enable verbose logging. Verbose logging includes debug-related stuff and
  /// detailed import statistics. This can have severe impact on import performance
  /// and memory consumption. However, it might be useful to find out why a file
  /// didn't read correctly.
  /// @param d AI_TRUE or AI_FALSE, your decision.
  void aiEnableVerboseLogging(
    int d,
  ) {
    return _aiEnableVerboseLogging(
      d,
    );
  }

  late final _aiEnableVerboseLogging_ptr =
      _lookup<ffi.NativeFunction<_c_aiEnableVerboseLogging>>(
          'aiEnableVerboseLogging');
  late final _dart_aiEnableVerboseLogging _aiEnableVerboseLogging =
      _aiEnableVerboseLogging_ptr.asFunction<_dart_aiEnableVerboseLogging>();

  /// Detach a custom log stream from the libraries' logging system.
  ///
  /// This is the counterpart of #aiAttachLogStream. If you attached a stream,
  /// don't forget to detach it again.
  /// @param stream The log stream to be detached.
  /// @return AI_SUCCESS if the log stream has been detached successfully.
  /// @see aiDetachAllLogStreams
  int aiDetachLogStream(
    ffi.Pointer<aiLogStream> stream,
  ) {
    return _aiDetachLogStream(
      stream,
    );
  }

  late final _aiDetachLogStream_ptr =
      _lookup<ffi.NativeFunction<_c_aiDetachLogStream>>('aiDetachLogStream');
  late final _dart_aiDetachLogStream _aiDetachLogStream =
      _aiDetachLogStream_ptr.asFunction<_dart_aiDetachLogStream>();

  /// Detach all active log streams from the libraries' logging system.
  /// This ensures that the logging system is terminated properly and all
  /// resources allocated by it are actually freed. If you attached a stream,
  /// don't forget to detach it again.
  /// @see aiAttachLogStream
  /// @see aiDetachLogStream
  void aiDetachAllLogStreams() {
    return _aiDetachAllLogStreams();
  }

  late final _aiDetachAllLogStreams_ptr =
      _lookup<ffi.NativeFunction<_c_aiDetachAllLogStreams>>(
          'aiDetachAllLogStreams');
  late final _dart_aiDetachAllLogStreams _aiDetachAllLogStreams =
      _aiDetachAllLogStreams_ptr.asFunction<_dart_aiDetachAllLogStreams>();

  /// Releases all resources associated with the given import process.
  ///
  /// Call this function after you're done with the imported data.
  /// @param pScene The imported data to release. NULL is a valid value.
  void aiReleaseImport(
    ffi.Pointer<aiScene> pScene,
  ) {
    return _aiReleaseImport(
      pScene,
    );
  }

  late final _aiReleaseImport_ptr =
      _lookup<ffi.NativeFunction<_c_aiReleaseImport>>('aiReleaseImport');
  late final _dart_aiReleaseImport _aiReleaseImport =
      _aiReleaseImport_ptr.asFunction<_dart_aiReleaseImport>();

  /// Returns the error text of the last failed import process.
  ///
  /// @return A textual description of the error that occurred at the last
  /// import process. NULL if there was no error. There can't be an error if you
  /// got a non-NULL #aiScene from #aiImportFile/#aiImportFileEx/#aiApplyPostProcessing.
  ffi.Pointer<ffi.Int8> aiGetErrorString() {
    return _aiGetErrorString();
  }

  late final _aiGetErrorString_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetErrorString>>('aiGetErrorString');
  late final _dart_aiGetErrorString _aiGetErrorString =
      _aiGetErrorString_ptr.asFunction<_dart_aiGetErrorString>();

  /// Returns whether a given file extension is supported by ASSIMP
  ///
  /// @param szExtension Extension for which the function queries support for.
  /// Must include a leading dot '.'. Example: ".3ds", ".md3"
  /// @return AI_TRUE if the file extension is supported.
  int aiIsExtensionSupported(
    ffi.Pointer<ffi.Int8> szExtension,
  ) {
    return _aiIsExtensionSupported(
      szExtension,
    );
  }

  late final _aiIsExtensionSupported_ptr =
      _lookup<ffi.NativeFunction<_c_aiIsExtensionSupported>>(
          'aiIsExtensionSupported');
  late final _dart_aiIsExtensionSupported _aiIsExtensionSupported =
      _aiIsExtensionSupported_ptr.asFunction<_dart_aiIsExtensionSupported>();

  /// Get a list of all file extensions supported by ASSIMP.
  ///
  /// If a file extension is contained in the list this does, of course, not
  /// mean that ASSIMP is able to load all files with this extension.
  /// @param szOut String to receive the extension list.
  /// Format of the list: "*.3ds;*.obj;*.dae". NULL is not a valid parameter.
  void aiGetExtensionList(
    ffi.Pointer<aiString> szOut,
  ) {
    return _aiGetExtensionList(
      szOut,
    );
  }

  late final _aiGetExtensionList_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetExtensionList>>('aiGetExtensionList');
  late final _dart_aiGetExtensionList _aiGetExtensionList =
      _aiGetExtensionList_ptr.asFunction<_dart_aiGetExtensionList>();

  /// Get the approximated storage required by an imported asset
  /// @param pIn Input asset.
  /// @param in Data structure to be filled.
  void aiGetMemoryRequirements(
    ffi.Pointer<aiScene> pIn,
    ffi.Pointer<aiMemoryInfo> in_1,
  ) {
    return _aiGetMemoryRequirements(
      pIn,
      in_1,
    );
  }

  late final _aiGetMemoryRequirements_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetMemoryRequirements>>(
          'aiGetMemoryRequirements');
  late final _dart_aiGetMemoryRequirements _aiGetMemoryRequirements =
      _aiGetMemoryRequirements_ptr.asFunction<_dart_aiGetMemoryRequirements>();

  /// Create an empty property store. Property stores are used to collect import
  /// settings.
  /// @return New property store. Property stores need to be manually destroyed using
  /// the #aiReleasePropertyStore API function.
  ffi.Pointer<aiPropertyStore> aiCreatePropertyStore() {
    return _aiCreatePropertyStore();
  }

  late final _aiCreatePropertyStore_ptr =
      _lookup<ffi.NativeFunction<_c_aiCreatePropertyStore>>(
          'aiCreatePropertyStore');
  late final _dart_aiCreatePropertyStore _aiCreatePropertyStore =
      _aiCreatePropertyStore_ptr.asFunction<_dart_aiCreatePropertyStore>();

  /// Delete a property store.
  /// @param p Property store to be deleted.
  void aiReleasePropertyStore(
    ffi.Pointer<aiPropertyStore> p,
  ) {
    return _aiReleasePropertyStore(
      p,
    );
  }

  late final _aiReleasePropertyStore_ptr =
      _lookup<ffi.NativeFunction<_c_aiReleasePropertyStore>>(
          'aiReleasePropertyStore');
  late final _dart_aiReleasePropertyStore _aiReleasePropertyStore =
      _aiReleasePropertyStore_ptr.asFunction<_dart_aiReleasePropertyStore>();

  /// Set an integer property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param value New value for the property
  void aiSetImportPropertyInteger(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Int8> szName,
    int value,
  ) {
    return _aiSetImportPropertyInteger(
      store,
      szName,
      value,
    );
  }

  late final _aiSetImportPropertyInteger_ptr =
      _lookup<ffi.NativeFunction<_c_aiSetImportPropertyInteger>>(
          'aiSetImportPropertyInteger');
  late final _dart_aiSetImportPropertyInteger _aiSetImportPropertyInteger =
      _aiSetImportPropertyInteger_ptr
          .asFunction<_dart_aiSetImportPropertyInteger>();

  /// Set a floating-point property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param value New value for the property
  void aiSetImportPropertyFloat(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Int8> szName,
    double value,
  ) {
    return _aiSetImportPropertyFloat(
      store,
      szName,
      value,
    );
  }

  late final _aiSetImportPropertyFloat_ptr =
      _lookup<ffi.NativeFunction<_c_aiSetImportPropertyFloat>>(
          'aiSetImportPropertyFloat');
  late final _dart_aiSetImportPropertyFloat _aiSetImportPropertyFloat =
      _aiSetImportPropertyFloat_ptr
          .asFunction<_dart_aiSetImportPropertyFloat>();

  /// Set a string property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyString(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param st New value for the property
  void aiSetImportPropertyString(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Int8> szName,
    ffi.Pointer<aiString> st,
  ) {
    return _aiSetImportPropertyString(
      store,
      szName,
      st,
    );
  }

  late final _aiSetImportPropertyString_ptr =
      _lookup<ffi.NativeFunction<_c_aiSetImportPropertyString>>(
          'aiSetImportPropertyString');
  late final _dart_aiSetImportPropertyString _aiSetImportPropertyString =
      _aiSetImportPropertyString_ptr
          .asFunction<_dart_aiSetImportPropertyString>();

  /// Set a matrix property.
  ///
  /// This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C
  /// interface, properties are always shared by all imports. It is not possible to
  /// specify them per import.
  ///
  /// @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
  /// @param szName Name of the configuration property to be set. All supported
  /// public properties are defined in the config.h header file (AI_CONFIG_XXX).
  /// @param mat New value for the property
  void aiSetImportPropertyMatrix(
    ffi.Pointer<aiPropertyStore> store,
    ffi.Pointer<ffi.Int8> szName,
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiSetImportPropertyMatrix(
      store,
      szName,
      mat,
    );
  }

  late final _aiSetImportPropertyMatrix_ptr =
      _lookup<ffi.NativeFunction<_c_aiSetImportPropertyMatrix>>(
          'aiSetImportPropertyMatrix');
  late final _dart_aiSetImportPropertyMatrix _aiSetImportPropertyMatrix =
      _aiSetImportPropertyMatrix_ptr
          .asFunction<_dart_aiSetImportPropertyMatrix>();

  /// Construct a quaternion from a 3x3 rotation matrix.
  /// @param quat Receives the output quaternion.
  /// @param mat Matrix to 'quaternionize'.
  /// @see aiQuaternion(const aiMatrix3x3& pRotMatrix)
  void aiCreateQuaternionFromMatrix(
    ffi.Pointer<aiQuaternion> quat,
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiCreateQuaternionFromMatrix(
      quat,
      mat,
    );
  }

  late final _aiCreateQuaternionFromMatrix_ptr =
      _lookup<ffi.NativeFunction<_c_aiCreateQuaternionFromMatrix>>(
          'aiCreateQuaternionFromMatrix');
  late final _dart_aiCreateQuaternionFromMatrix _aiCreateQuaternionFromMatrix =
      _aiCreateQuaternionFromMatrix_ptr
          .asFunction<_dart_aiCreateQuaternionFromMatrix>();

  /// Decompose a transformation matrix into its rotational, translational and
  /// scaling components.
  ///
  /// @param mat Matrix to decompose
  /// @param scaling Receives the scaling component
  /// @param rotation Receives the rotational component
  /// @param position Receives the translational component.
  /// @see aiMatrix4x4::Decompose (aiVector3D&, aiQuaternion&, aiVector3D&) const;
  void aiDecomposeMatrix(
    ffi.Pointer<aiMatrix4x4> mat,
    ffi.Pointer<aiVector3D> scaling,
    ffi.Pointer<aiQuaternion> rotation,
    ffi.Pointer<aiVector3D> position,
  ) {
    return _aiDecomposeMatrix(
      mat,
      scaling,
      rotation,
      position,
    );
  }

  late final _aiDecomposeMatrix_ptr =
      _lookup<ffi.NativeFunction<_c_aiDecomposeMatrix>>('aiDecomposeMatrix');
  late final _dart_aiDecomposeMatrix _aiDecomposeMatrix =
      _aiDecomposeMatrix_ptr.asFunction<_dart_aiDecomposeMatrix>();

  /// Transpose a 4x4 matrix.
  /// @param mat Pointer to the matrix to be transposed
  void aiTransposeMatrix4(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiTransposeMatrix4(
      mat,
    );
  }

  late final _aiTransposeMatrix4_ptr =
      _lookup<ffi.NativeFunction<_c_aiTransposeMatrix4>>('aiTransposeMatrix4');
  late final _dart_aiTransposeMatrix4 _aiTransposeMatrix4 =
      _aiTransposeMatrix4_ptr.asFunction<_dart_aiTransposeMatrix4>();

  /// Transpose a 3x3 matrix.
  /// @param mat Pointer to the matrix to be transposed
  void aiTransposeMatrix3(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiTransposeMatrix3(
      mat,
    );
  }

  late final _aiTransposeMatrix3_ptr =
      _lookup<ffi.NativeFunction<_c_aiTransposeMatrix3>>('aiTransposeMatrix3');
  late final _dart_aiTransposeMatrix3 _aiTransposeMatrix3 =
      _aiTransposeMatrix3_ptr.asFunction<_dart_aiTransposeMatrix3>();

  /// Transform a vector by a 3x3 matrix
  /// @param vec Vector to be transformed.
  /// @param mat Matrix to transform the vector with.
  void aiTransformVecByMatrix3(
    ffi.Pointer<aiVector3D> vec,
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiTransformVecByMatrix3(
      vec,
      mat,
    );
  }

  late final _aiTransformVecByMatrix3_ptr =
      _lookup<ffi.NativeFunction<_c_aiTransformVecByMatrix3>>(
          'aiTransformVecByMatrix3');
  late final _dart_aiTransformVecByMatrix3 _aiTransformVecByMatrix3 =
      _aiTransformVecByMatrix3_ptr.asFunction<_dart_aiTransformVecByMatrix3>();

  /// Transform a vector by a 4x4 matrix
  /// @param vec Vector to be transformed.
  /// @param mat Matrix to transform the vector with.
  void aiTransformVecByMatrix4(
    ffi.Pointer<aiVector3D> vec,
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiTransformVecByMatrix4(
      vec,
      mat,
    );
  }

  late final _aiTransformVecByMatrix4_ptr =
      _lookup<ffi.NativeFunction<_c_aiTransformVecByMatrix4>>(
          'aiTransformVecByMatrix4');
  late final _dart_aiTransformVecByMatrix4 _aiTransformVecByMatrix4 =
      _aiTransformVecByMatrix4_ptr.asFunction<_dart_aiTransformVecByMatrix4>();

  /// Multiply two 4x4 matrices.
  /// @param dst First factor, receives result.
  /// @param src Matrix to be multiplied with 'dst'.
  void aiMultiplyMatrix4(
    ffi.Pointer<aiMatrix4x4> dst,
    ffi.Pointer<aiMatrix4x4> src,
  ) {
    return _aiMultiplyMatrix4(
      dst,
      src,
    );
  }

  late final _aiMultiplyMatrix4_ptr =
      _lookup<ffi.NativeFunction<_c_aiMultiplyMatrix4>>('aiMultiplyMatrix4');
  late final _dart_aiMultiplyMatrix4 _aiMultiplyMatrix4 =
      _aiMultiplyMatrix4_ptr.asFunction<_dart_aiMultiplyMatrix4>();

  /// Multiply two 3x3 matrices.
  /// @param dst First factor, receives result.
  /// @param src Matrix to be multiplied with 'dst'.
  void aiMultiplyMatrix3(
    ffi.Pointer<aiMatrix3x3> dst,
    ffi.Pointer<aiMatrix3x3> src,
  ) {
    return _aiMultiplyMatrix3(
      dst,
      src,
    );
  }

  late final _aiMultiplyMatrix3_ptr =
      _lookup<ffi.NativeFunction<_c_aiMultiplyMatrix3>>('aiMultiplyMatrix3');
  late final _dart_aiMultiplyMatrix3 _aiMultiplyMatrix3 =
      _aiMultiplyMatrix3_ptr.asFunction<_dart_aiMultiplyMatrix3>();

  /// Get a 3x3 identity matrix.
  /// @param mat Matrix to receive its personal identity
  void aiIdentityMatrix3(
    ffi.Pointer<aiMatrix3x3> mat,
  ) {
    return _aiIdentityMatrix3(
      mat,
    );
  }

  late final _aiIdentityMatrix3_ptr =
      _lookup<ffi.NativeFunction<_c_aiIdentityMatrix3>>('aiIdentityMatrix3');
  late final _dart_aiIdentityMatrix3 _aiIdentityMatrix3 =
      _aiIdentityMatrix3_ptr.asFunction<_dart_aiIdentityMatrix3>();

  /// Get a 4x4 identity matrix.
  /// @param mat Matrix to receive its personal identity
  void aiIdentityMatrix4(
    ffi.Pointer<aiMatrix4x4> mat,
  ) {
    return _aiIdentityMatrix4(
      mat,
    );
  }

  late final _aiIdentityMatrix4_ptr =
      _lookup<ffi.NativeFunction<_c_aiIdentityMatrix4>>('aiIdentityMatrix4');
  late final _dart_aiIdentityMatrix4 _aiIdentityMatrix4 =
      _aiIdentityMatrix4_ptr.asFunction<_dart_aiIdentityMatrix4>();

  /// Returns the number of import file formats available in the current Assimp build.
  /// Use aiGetImportFormatDescription() to retrieve infos of a specific import format.
  int aiGetImportFormatCount() {
    return _aiGetImportFormatCount();
  }

  late final _aiGetImportFormatCount_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetImportFormatCount>>(
          'aiGetImportFormatCount');
  late final _dart_aiGetImportFormatCount _aiGetImportFormatCount =
      _aiGetImportFormatCount_ptr.asFunction<_dart_aiGetImportFormatCount>();

  /// Returns a description of the nth import file format. Use #aiGetImportFormatCount()
  /// to learn how many import formats are supported.
  /// @param pIndex Index of the import format to retrieve information for. Valid range is
  /// 0 to #aiGetImportFormatCount()
  /// @return A description of that specific import format. NULL if pIndex is out of range.
  ffi.Pointer<aiImporterDesc> aiGetImportFormatDescription(
    int pIndex,
  ) {
    return _aiGetImportFormatDescription(
      pIndex,
    );
  }

  late final _aiGetImportFormatDescription_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetImportFormatDescription>>(
          'aiGetImportFormatDescription');
  late final _dart_aiGetImportFormatDescription _aiGetImportFormatDescription =
      _aiGetImportFormatDescription_ptr
          .asFunction<_dart_aiGetImportFormatDescription>();

  late final ffi.Pointer<ffi.Float> _ai_epsilon_1 =
      _lookup<ffi.Float>('ai_epsilon');

  double get ai_epsilon_1 => _ai_epsilon_1.value;

  set ai_epsilon_1(double value) => _ai_epsilon_1.value = value;

  /// @brief Retrieve a material property with a specific key from the material
  ///
  /// @param pMat Pointer to the input material. May not be NULL
  /// @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
  /// @param type Specifies the type of the texture to be retrieved (
  /// e.g. diffuse, specular, height map ...)
  /// @param index Index of the texture to be retrieved.
  /// @param pPropOut Pointer to receive a pointer to a valid aiMaterialProperty
  /// structure or NULL if the key has not been found.
  int aiGetMaterialProperty(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Int8> pKey,
    int type,
    int index,
    ffi.Pointer<ffi.Pointer<aiMaterialProperty>> pPropOut,
  ) {
    return _aiGetMaterialProperty(
      pMat,
      pKey,
      type,
      index,
      pPropOut,
    );
  }

  late final _aiGetMaterialProperty_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetMaterialProperty>>(
          'aiGetMaterialProperty');
  late final _dart_aiGetMaterialProperty _aiGetMaterialProperty =
      _aiGetMaterialProperty_ptr.asFunction<_dart_aiGetMaterialProperty>();

  /// @brief Retrieve an array of float values with a specific key
  /// from the material
  ///
  /// Pass one of the AI_MATKEY_XXX constants for the last three parameters (the
  /// example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)
  /// @code
  /// aiUVTransform trafo;
  /// unsigned int max = sizeof(aiUVTransform);
  /// if (AI_SUCCESS != aiGetMaterialFloatArray(mat, AI_MATKEY_UVTRANSFORM(aiTextureType_DIFFUSE,0),
  /// (float*)&trafo, &max) || sizeof(aiUVTransform) != max)
  /// {
  /// // error handling
  /// }
  /// @endcode
  ///
  /// @param pMat Pointer to the input material. May not be NULL
  /// @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
  /// @param pOut Pointer to a buffer to receive the result.
  /// @param pMax Specifies the size of the given buffer, in float's.
  /// Receives the number of values (not bytes!) read.
  /// @param type (see the code sample above)
  /// @param index (see the code sample above)
  /// @return Specifies whether the key has been found. If not, the output
  /// arrays remains unmodified and pMax is set to 0.
  int aiGetMaterialFloatArray(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Int8> pKey,
    int type,
    int index,
    ffi.Pointer<ffi.Float> pOut,
    ffi.Pointer<ffi.Uint32> pMax,
  ) {
    return _aiGetMaterialFloatArray(
      pMat,
      pKey,
      type,
      index,
      pOut,
      pMax,
    );
  }

  late final _aiGetMaterialFloatArray_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetMaterialFloatArray>>(
          'aiGetMaterialFloatArray');
  late final _dart_aiGetMaterialFloatArray _aiGetMaterialFloatArray =
      _aiGetMaterialFloatArray_ptr.asFunction<_dart_aiGetMaterialFloatArray>();

  /// @brief Retrieve an array of integer values with a specific key
  /// from a material
  ///
  /// See the sample for aiGetMaterialFloatArray for more information.
  int aiGetMaterialIntegerArray(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Int8> pKey,
    int type,
    int index,
    ffi.Pointer<ffi.Int32> pOut,
    ffi.Pointer<ffi.Uint32> pMax,
  ) {
    return _aiGetMaterialIntegerArray(
      pMat,
      pKey,
      type,
      index,
      pOut,
      pMax,
    );
  }

  late final _aiGetMaterialIntegerArray_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetMaterialIntegerArray>>(
          'aiGetMaterialIntegerArray');
  late final _dart_aiGetMaterialIntegerArray _aiGetMaterialIntegerArray =
      _aiGetMaterialIntegerArray_ptr
          .asFunction<_dart_aiGetMaterialIntegerArray>();

  /// @brief Retrieve a color value from the material property table
  ///
  /// See the sample for aiGetMaterialFloat for more information
  int aiGetMaterialColor(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Int8> pKey,
    int type,
    int index,
    ffi.Pointer<aiColor4D> pOut,
  ) {
    return _aiGetMaterialColor(
      pMat,
      pKey,
      type,
      index,
      pOut,
    );
  }

  late final _aiGetMaterialColor_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetMaterialColor>>('aiGetMaterialColor');
  late final _dart_aiGetMaterialColor _aiGetMaterialColor =
      _aiGetMaterialColor_ptr.asFunction<_dart_aiGetMaterialColor>();

  /// @brief Retrieve a aiUVTransform value from the material property table
  ///
  /// See the sample for aiGetMaterialFloat for more information
  int aiGetMaterialUVTransform(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Int8> pKey,
    int type,
    int index,
    ffi.Pointer<aiUVTransform> pOut,
  ) {
    return _aiGetMaterialUVTransform(
      pMat,
      pKey,
      type,
      index,
      pOut,
    );
  }

  late final _aiGetMaterialUVTransform_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetMaterialUVTransform>>(
          'aiGetMaterialUVTransform');
  late final _dart_aiGetMaterialUVTransform _aiGetMaterialUVTransform =
      _aiGetMaterialUVTransform_ptr
          .asFunction<_dart_aiGetMaterialUVTransform>();

  /// @brief Retrieve a string from the material property table
  ///
  /// See the sample for aiGetMaterialFloat for more information.
  int aiGetMaterialString(
    ffi.Pointer<aiMaterial> pMat,
    ffi.Pointer<ffi.Int8> pKey,
    int type,
    int index,
    ffi.Pointer<aiString> pOut,
  ) {
    return _aiGetMaterialString(
      pMat,
      pKey,
      type,
      index,
      pOut,
    );
  }

  late final _aiGetMaterialString_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetMaterialString>>(
          'aiGetMaterialString');
  late final _dart_aiGetMaterialString _aiGetMaterialString =
      _aiGetMaterialString_ptr.asFunction<_dart_aiGetMaterialString>();

  /// Get the number of textures for a particular texture type.
  /// @param[in] pMat Pointer to the input material. May not be NULL
  /// @param type Texture type to check for
  /// @return Number of textures for this type.
  /// @note A texture can be easily queried using #aiGetMaterialTexture()
  int aiGetMaterialTextureCount(
    ffi.Pointer<aiMaterial> pMat,
    int type,
  ) {
    return _aiGetMaterialTextureCount(
      pMat,
      type,
    );
  }

  late final _aiGetMaterialTextureCount_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetMaterialTextureCount>>(
          'aiGetMaterialTextureCount');
  late final _dart_aiGetMaterialTextureCount _aiGetMaterialTextureCount =
      _aiGetMaterialTextureCount_ptr
          .asFunction<_dart_aiGetMaterialTextureCount>();

  int aiGetMaterialTexture(
    ffi.Pointer<aiMaterial> mat,
    int type,
    int index,
    ffi.Pointer<aiString> path,
    ffi.Pointer<ffi.Int32> mapping,
    ffi.Pointer<ffi.Uint32> uvindex,
    ffi.Pointer<ffi.Float> blend,
    ffi.Pointer<ffi.Int32> op,
    ffi.Pointer<ffi.Int32> mapmode,
    ffi.Pointer<ffi.Uint32> flags,
  ) {
    return _aiGetMaterialTexture(
      mat,
      type,
      index,
      path,
      mapping,
      uvindex,
      blend,
      op,
      mapmode,
      flags,
    );
  }

  late final _aiGetMaterialTexture_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetMaterialTexture>>(
          'aiGetMaterialTexture');
  late final _dart_aiGetMaterialTexture _aiGetMaterialTexture =
      _aiGetMaterialTexture_ptr.asFunction<_dart_aiGetMaterialTexture>();

  /// @brief Returns a string with legal copyright and licensing information
  /// about Assimp. The string may include multiple lines.
  /// @return Pointer to static string.
  ffi.Pointer<ffi.Int8> aiGetLegalString() {
    return _aiGetLegalString();
  }

  late final _aiGetLegalString_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetLegalString>>('aiGetLegalString');
  late final _dart_aiGetLegalString _aiGetLegalString =
      _aiGetLegalString_ptr.asFunction<_dart_aiGetLegalString>();

  /// @brief Returns the current minor version number of Assimp.
  /// @return Minor version of the Assimp runtime the application was
  /// linked/built against
  int aiGetVersionMinor() {
    return _aiGetVersionMinor();
  }

  late final _aiGetVersionMinor_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetVersionMinor>>('aiGetVersionMinor');
  late final _dart_aiGetVersionMinor _aiGetVersionMinor =
      _aiGetVersionMinor_ptr.asFunction<_dart_aiGetVersionMinor>();

  /// @brief Returns the current major version number of Assimp.
  /// @return Major version of the Assimp runtime the application was
  /// linked/built against
  int aiGetVersionMajor() {
    return _aiGetVersionMajor();
  }

  late final _aiGetVersionMajor_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetVersionMajor>>('aiGetVersionMajor');
  late final _dart_aiGetVersionMajor _aiGetVersionMajor =
      _aiGetVersionMajor_ptr.asFunction<_dart_aiGetVersionMajor>();

  /// @brief Returns the repository revision of the Assimp runtime.
  /// @return SVN Repository revision number of the Assimp runtime the
  /// application was linked/built against.
  int aiGetVersionRevision() {
    return _aiGetVersionRevision();
  }

  late final _aiGetVersionRevision_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetVersionRevision>>(
          'aiGetVersionRevision');
  late final _dart_aiGetVersionRevision _aiGetVersionRevision =
      _aiGetVersionRevision_ptr.asFunction<_dart_aiGetVersionRevision>();

  /// @brief Returns the branchname of the Assimp runtime.
  /// @return The current branch name.
  ffi.Pointer<ffi.Int8> aiGetBranchName() {
    return _aiGetBranchName();
  }

  late final _aiGetBranchName_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetBranchName>>('aiGetBranchName');
  late final _dart_aiGetBranchName _aiGetBranchName =
      _aiGetBranchName_ptr.asFunction<_dart_aiGetBranchName>();

  /// @brief Returns assimp's compile flags
  /// @return Any bitwise combination of the ASSIMP_CFLAGS_xxx constants.
  int aiGetCompileFlags() {
    return _aiGetCompileFlags();
  }

  late final _aiGetCompileFlags_ptr =
      _lookup<ffi.NativeFunction<_c_aiGetCompileFlags>>('aiGetCompileFlags');
  late final _dart_aiGetCompileFlags _aiGetCompileFlags =
      _aiGetCompileFlags_ptr.asFunction<_dart_aiGetCompileFlags>();
}

abstract class aiComponent {
  static const int aiComponent_NORMALS = 2;
  static const int aiComponent_TANGENTS_AND_BITANGENTS = 4;
  static const int aiComponent_COLORS = 8;
  static const int aiComponent_TEXCOORDS = 16;
  static const int aiComponent_BONEWEIGHTS = 32;
  static const int aiComponent_ANIMATIONS = 64;
  static const int aiComponent_TEXTURES = 128;
  static const int aiComponent_LIGHTS = 256;
  static const int aiComponent_CAMERAS = 512;
  static const int aiComponent_MESHES = 1024;
  static const int aiComponent_MATERIALS = 2048;
  static const int _aiComponent_Force32Bit = -1610612737;
}

class aiVector3D extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double z;
}

class aiVector2D extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;
}

class aiColor4D extends ffi.Struct {
  @ffi.Float()
  external double r;

  @ffi.Float()
  external double g;

  @ffi.Float()
  external double b;

  @ffi.Float()
  external double a;
}

class aiMatrix3x3 extends ffi.Struct {
  @ffi.Float()
  external double a1;

  @ffi.Float()
  external double a2;

  @ffi.Float()
  external double a3;

  @ffi.Float()
  external double b1;

  @ffi.Float()
  external double b2;

  @ffi.Float()
  external double b3;

  @ffi.Float()
  external double c1;

  @ffi.Float()
  external double c2;

  @ffi.Float()
  external double c3;
}

class aiMatrix4x4 extends ffi.Struct {
  @ffi.Float()
  external double a1;

  @ffi.Float()
  external double a2;

  @ffi.Float()
  external double a3;

  @ffi.Float()
  external double a4;

  @ffi.Float()
  external double b1;

  @ffi.Float()
  external double b2;

  @ffi.Float()
  external double b3;

  @ffi.Float()
  external double b4;

  @ffi.Float()
  external double c1;

  @ffi.Float()
  external double c2;

  @ffi.Float()
  external double c3;

  @ffi.Float()
  external double c4;

  @ffi.Float()
  external double d1;

  @ffi.Float()
  external double d2;

  @ffi.Float()
  external double d3;

  @ffi.Float()
  external double d4;
}

class aiQuaternion extends ffi.Struct {
  @ffi.Float()
  external double w;

  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double z;
}

class aiPlane extends ffi.Struct {
  @ffi.Float()
  external double a;

  @ffi.Float()
  external double b;

  @ffi.Float()
  external double c;

  @ffi.Float()
  external double d;
}

class aiRay extends ffi.Struct {
  external aiVector3D pos;

  external aiVector3D dir;
}

class aiColor3D extends ffi.Struct {
  @ffi.Float()
  external double r;

  @ffi.Float()
  external double g;

  @ffi.Float()
  external double b;
}

class aiString extends ffi.Struct {
  @ffi.Uint32()
  external int length;

  @ffi.Array.multi([1024])
  external ffi.Array<ffi.Int8> data;
}

abstract class aiReturn {
  static const int aiReturn_SUCCESS = 0;
  static const int aiReturn_FAILURE = -1;
  static const int aiReturn_OUTOFMEMORY = -3;
  static const int _AI_ENFORCE_ENUM_SIZE = 2147483647;
}

abstract class aiOrigin {
  static const int aiOrigin_SET = 0;
  static const int aiOrigin_CUR = 1;
  static const int aiOrigin_END = 2;
  static const int _AI_ORIGIN_ENFORCE_ENUM_SIZE = 2147483647;
}

abstract class aiDefaultLogStream {
  static const int aiDefaultLogStream_FILE = 1;
  static const int aiDefaultLogStream_STDOUT = 2;
  static const int aiDefaultLogStream_STDERR = 4;
  static const int aiDefaultLogStream_DEBUGGER = 8;
  static const int _AI_DLS_ENFORCE_ENUM_SIZE = 2147483647;
}

class aiMemoryInfo extends ffi.Struct {
  @ffi.Uint32()
  external int textures;

  @ffi.Uint32()
  external int materials;

  @ffi.Uint32()
  external int meshes;

  @ffi.Uint32()
  external int nodes;

  @ffi.Uint32()
  external int animations;

  @ffi.Uint32()
  external int cameras;

  @ffi.Uint32()
  external int lights;

  @ffi.Uint32()
  external int total;
}

class aiScene extends ffi.Opaque {}

class aiFileIO extends ffi.Opaque {}

/// Describes an file format which Assimp can export to. Use #aiGetExportFormatCount() to
/// learn how many export formats the current Assimp build supports and #aiGetExportFormatDescription()
/// to retrieve a description of an export format option.
class aiExportFormatDesc extends ffi.Struct {
  /// a short string ID to uniquely identify the export format. Use this ID string to
  /// specify which file format you want to export to when calling #aiExportScene().
  /// Example: "dae" or "obj"
  external ffi.Pointer<ffi.Int8> id;

  /// A short description of the file format to present to users. Useful if you want
  /// to allow the user to select an export format.
  external ffi.Pointer<ffi.Int8> description;

  /// Recommended file extension for the exported file in lower case.
  external ffi.Pointer<ffi.Int8> fileExtension;
}

/// Describes a blob of exported scene data. Use #aiExportSceneToBlob() to create a blob containing an
/// exported scene. The memory referred by this structure is owned by Assimp.
/// to free its resources. Don't try to free the memory on your side - it will crash for most build configurations
/// due to conflicting heaps.
///
/// Blobs can be nested - each blob may reference another blob, which may in turn reference another blob and so on.
/// This is used when exporters write more than one output file for a given #aiScene. See the remarks for
/// #aiExportDataBlob::name for more information.
class aiExportDataBlob extends ffi.Struct {
  /// Size of the data in bytes
  @ffi.Uint64()
  external int size;

  /// The data.
  external ffi.Pointer<ffi.Void> data;

  /// Name of the blob. An empty string always
  /// indicates the first (and primary) blob,
  /// which contains the actual file data.
  /// Any other blobs are auxiliary files produced
  /// by exporters (i.e. material files). Existence
  /// of such files depends on the file format. Most
  /// formats don't split assets across multiple files.
  ///
  /// If used, blob names usually contain the file
  /// extension that should be used when writing
  /// the data to disc.
  external aiString name;

  /// Pointer to the next blob in the chain or NULL if there is none.
  external ffi.Pointer<aiExportDataBlob> next;
}

/// @brief C-API: File callbacks
///
/// Actually, it's a data structure to wrap a set of fXXXX (e.g fopen)
/// replacement functions.
///
/// The default implementation of the functions utilizes the fXXX functions from
/// the CRT. However, you can supply a custom implementation to Assimp by
/// delivering a custom aiFileIO. Use this to enable reading from other sources,
/// such as ZIP archives or memory locations.
class aiFile extends ffi.Struct {
  /// Callback to read from a file
  external ffi.Pointer<ffi.NativeFunction<aiFileReadProc>> ReadProc;

  /// Callback to write to a file
  external ffi.Pointer<ffi.NativeFunction<aiFileWriteProc>> WriteProc;

  /// Callback to retrieve the current position of
  /// the file cursor (ftell())
  external ffi.Pointer<ffi.NativeFunction<aiFileTellProc>> TellProc;

  /// Callback to retrieve the size of the file,
  /// in bytes
  external ffi.Pointer<ffi.NativeFunction<aiFileTellProc>> FileSizeProc;

  /// Callback to set the current position
  /// of the file cursor (fseek())
  external ffi.Pointer<ffi.NativeFunction<aiFileSeek>> SeekProc;

  /// Callback to flush the file contents
  external ffi.Pointer<ffi.NativeFunction<aiFileFlushProc>> FlushProc;

  /// User-defined, opaque data
  external ffi.Pointer<ffi.Int8> UserData;
}

/// Mixed set of flags for #aiImporterDesc, indicating some features
/// common to many importers
abstract class aiImporterFlags {
  /// Indicates that there is a textual encoding of the
  /// file format; and that it is supported.
  static const int aiImporterFlags_SupportTextFlavour = 1;

  /// Indicates that there is a binary encoding of the
  /// file format; and that it is supported.
  static const int aiImporterFlags_SupportBinaryFlavour = 2;

  /// Indicates that there is a compressed encoding of the
  /// file format; and that it is supported.
  static const int aiImporterFlags_SupportCompressedFlavour = 4;

  /// Indicates that the importer reads only a very particular
  /// subset of the file format. This happens commonly for
  /// declarative or procedural formats which cannot easily
  /// be mapped to #aiScene
  static const int aiImporterFlags_LimitedSupport = 8;

  /// Indicates that the importer is highly experimental and
  /// should be used with care. This only happens for trunk
  /// (i.e. SVN) versions, experimental code is not included
  /// in releases.
  static const int aiImporterFlags_Experimental = 16;
}

/// Meta information about a particular importer. Importers need to fill
/// this structure, but they can freely decide how talkative they are.
/// A common use case for loader meta info is a user interface
/// in which the user can choose between various import/export file
/// formats. Building such an UI by hand means a lot of maintenance
/// as importers/exporters are added to Assimp, so it might be useful
/// to have a common mechanism to query some rough importer
/// characteristics.
class aiImporterDesc extends ffi.Struct {
  /// Full name of the importer (i.e. Blender3D importer)
  external ffi.Pointer<ffi.Int8> mName;

  /// Original author (left blank if unknown or whole assimp team)
  external ffi.Pointer<ffi.Int8> mAuthor;

  /// Current maintainer, left blank if the author maintains
  external ffi.Pointer<ffi.Int8> mMaintainer;

  /// Implementation comments, i.e. unimplemented features
  external ffi.Pointer<ffi.Int8> mComments;

  /// These flags indicate some characteristics common to many
  /// importers.
  @ffi.Uint32()
  external int mFlags;

  /// Minimum format version that can be loaded im major.minor format,
  /// both are set to 0 if there is either no version scheme
  /// or if the loader doesn't care.
  @ffi.Uint32()
  external int mMinMajor;

  @ffi.Uint32()
  external int mMinMinor;

  /// Maximum format version that can be loaded im major.minor format,
  /// both are set to 0 if there is either no version scheme
  /// or if the loader doesn't care. Loaders that expect to be
  /// forward-compatible to potential future format versions should
  /// indicate  zero, otherwise they should specify the current
  /// maximum version.
  @ffi.Uint32()
  external int mMaxMajor;

  @ffi.Uint32()
  external int mMaxMinor;

  /// List of file extensions this importer can handle.
  /// List entries are separated by space characters.
  /// All entries are lower case without a leading dot (i.e.
  /// "xml dae" would be a valid value. Note that multiple
  /// importers may respond to the same file extension -
  /// assimp calls all importers in the order in which they
  /// are registered and each importer gets the opportunity
  /// to load the file until one importer "claims" the file. Apart
  /// from file extension checks, importers typically use
  /// other methods to quickly reject files (i.e. magic
  /// words) so this does not mean that common or generic
  /// file extensions such as XML would be tediously slow.
  external ffi.Pointer<ffi.Int8> mFileExtensions;
}

/// C-API: Represents a log stream. A log stream receives all log messages and
/// streams them _somewhere_.
/// @see aiGetPredefinedLogStream
/// @see aiAttachLogStream
/// @see aiDetachLogStream
class aiLogStream extends ffi.Struct {
  /// callback to be called
  external ffi.Pointer<ffi.NativeFunction<aiLogStreamCallback>> callback;

  /// user data to be passed to the callback
  external ffi.Pointer<ffi.Int8> user;
}

/// C-API: Represents an opaque set of settings to be used during importing.
/// @see aiCreatePropertyStore
/// @see aiReleasePropertyStore
/// @see aiImportFileExWithProperties
/// @see aiSetPropertyInteger
/// @see aiSetPropertyFloat
/// @see aiSetPropertyString
/// @see aiSetPropertyMatrix
class aiPropertyStore extends ffi.Struct {
  @ffi.Int8()
  external int sentinel;
}

/// @enum  aiPostProcessSteps
/// @brief Defines the flags for all possible post processing steps.
///
/// @note Some steps are influenced by properties set on the Assimp::Importer itself
///
/// @see Assimp::Importer::ReadFile()
/// @see Assimp::Importer::SetPropertyInteger()
/// @see aiImportFile
/// @see aiImportFileEx
abstract class aiPostProcessSteps {
  /// <hr>Calculates the tangents and bitangents for the imported meshes.
  ///
  /// Does nothing if a mesh does not have normals. You might want this post
  /// processing step to be executed if you plan to use tangent space calculations
  /// such as normal mapping  applied to the meshes. There's an importer property,
  /// <tt>#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</tt>, which allows you to specify
  /// a maximum smoothing angle for the algorithm. However, usually you'll
  /// want to leave it at the default value.
  static const int aiProcess_CalcTangentSpace = 1;

  /// <hr>Identifies and joins identical vertex data sets within all
  /// imported meshes.
  ///
  /// After this step is run, each mesh contains unique vertices,
  /// so a vertex may be used by multiple faces. You usually want
  /// to use this post processing step. If your application deals with
  /// indexed geometry, this step is compulsory or you'll just waste rendering
  /// time. <b>If this flag is not specified</b>, no vertices are referenced by
  /// more than one face and <b>no index buffer is required</b> for rendering.
  static const int aiProcess_JoinIdenticalVertices = 2;

  /// <hr>Converts all the imported data to a left-handed coordinate space.
  ///
  /// By default the data is returned in a right-handed coordinate space (which
  /// OpenGL prefers). In this space, +X points to the right,
  /// +Z points towards the viewer, and +Y points upwards. In the DirectX
  /// coordinate space +X points to the right, +Y points upwards, and +Z points
  /// away from the viewer.
  ///
  /// You'll probably want to consider this flag if you use Direct3D for
  /// rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this
  /// setting and bundles all conversions typically required for D3D-based
  /// applications.
  static const int aiProcess_MakeLeftHanded = 4;

  /// <hr>Triangulates all faces of all meshes.
  ///
  /// By default the imported mesh data might contain faces with more than 3
  /// indices. For rendering you'll usually want all faces to be triangles.
  /// This post processing step splits up faces with more than 3 indices into
  /// triangles. Line and point primitives are *not* modified! If you want
  /// 'triangles only' with no other kinds of primitives, try the following
  /// solution:
  /// <ul>
  /// <li>Specify both #aiProcess_Triangulate and #aiProcess_SortByPType </li>
  /// <li>Ignore all point and line meshes when you process assimp's output</li>
  /// </ul>
  static const int aiProcess_Triangulate = 8;

  /// <hr>Removes some parts of the data structure (animations, materials,
  /// light sources, cameras, textures, vertex components).
  ///
  /// The  components to be removed are specified in a separate
  /// importer property, <tt>#AI_CONFIG_PP_RVC_FLAGS</tt>. This is quite useful
  /// if you don't need all parts of the output structure. Vertex colors
  /// are rarely used today for example... Calling this step to remove unneeded
  /// data from the pipeline as early as possible results in increased
  /// performance and a more optimized output data structure.
  /// This step is also useful if you want to force Assimp to recompute
  /// normals or tangents. The corresponding steps don't recompute them if
  /// they're already there (loaded from the source asset). By using this
  /// step you can make sure they are NOT there.
  ///
  /// This flag is a poor one, mainly because its purpose is usually
  /// misunderstood. Consider the following case: a 3D model has been exported
  /// from a CAD app, and it has per-face vertex colors. Vertex positions can't be
  /// shared, thus the #aiProcess_JoinIdenticalVertices step fails to
  /// optimize the data because of these nasty little vertex colors.
  /// Most apps don't even process them, so it's all for nothing. By using
  /// this step, unneeded components are excluded as early as possible
  /// thus opening more room for internal optimizations.
  static const int aiProcess_RemoveComponent = 16;

  /// <hr>Generates normals for all faces of all meshes.
  ///
  /// This is ignored if normals are already there at the time this flag
  /// is evaluated. Model importers try to load them from the source file, so
  /// they're usually already there. Face normals are shared between all points
  /// of a single face, so a single point can have multiple normals, which
  /// forces the library to duplicate vertices in some cases.
  /// #aiProcess_JoinIdenticalVertices is *senseless* then.
  ///
  /// This flag may not be specified together with #aiProcess_GenSmoothNormals.
  static const int aiProcess_GenNormals = 32;

  /// <hr>Generates smooth normals for all vertices in the mesh.
  ///
  /// This is ignored if normals are already there at the time this flag
  /// is evaluated. Model importers try to load them from the source file, so
  /// they're usually already there.
  ///
  /// This flag may not be specified together with
  /// #aiProcess_GenNormals. There's a importer property,
  /// <tt>#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</tt> which allows you to specify
  /// an angle maximum for the normal smoothing algorithm. Normals exceeding
  /// this limit are not smoothed, resulting in a 'hard' seam between two faces.
  /// Using a decent angle here (e.g. 80 degrees) results in very good visual
  /// appearance.
  static const int aiProcess_GenSmoothNormals = 64;

  /// <hr>Splits large meshes into smaller sub-meshes.
  ///
  /// This is quite useful for real-time rendering, where the number of triangles
  /// which can be maximally processed in a single draw-call is limited
  /// by the video driver/hardware. The maximum vertex buffer is usually limited
  /// too. Both requirements can be met with this step: you may specify both a
  /// triangle and vertex limit for a single mesh.
  ///
  /// The split limits can (and should!) be set through the
  /// <tt>#AI_CONFIG_PP_SLM_VERTEX_LIMIT</tt> and <tt>#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</tt>
  /// importer properties. The default values are <tt>#AI_SLM_DEFAULT_MAX_VERTICES</tt> and
  /// <tt>#AI_SLM_DEFAULT_MAX_TRIANGLES</tt>.
  ///
  /// Note that splitting is generally a time-consuming task, but only if there's
  /// something to split. The use of this step is recommended for most users.
  static const int aiProcess_SplitLargeMeshes = 128;

  /// <hr>Removes the node graph and pre-transforms all vertices with
  /// the local transformation matrices of their nodes.
  ///
  /// The output scene still contains nodes, however there is only a
  /// root node with children, each one referencing only one mesh,
  /// and each mesh referencing one material. For rendering, you can
  /// simply render all meshes in order - you don't need to pay
  /// attention to local transformations and the node hierarchy.
  /// Animations are removed during this step.
  /// This step is intended for applications without a scenegraph.
  /// The step CAN cause some problems: if e.g. a mesh of the asset
  /// contains normals and another, using the same material index, does not,
  /// they will be brought together, but the first meshes's part of
  /// the normal list is zeroed. However, these artifacts are rare.
  /// @note The <tt>#AI_CONFIG_PP_PTV_NORMALIZE</tt> configuration property
  /// can be set to normalize the scene's spatial dimension to the -1...1
  /// range.
  static const int aiProcess_PreTransformVertices = 256;

  /// <hr>Limits the number of bones simultaneously affecting a single vertex
  /// to a maximum value.
  ///
  /// If any vertex is affected by more than the maximum number of bones, the least
  /// important vertex weights are removed and the remaining vertex weights are
  /// renormalized so that the weights still sum up to 1.
  /// The default bone weight limit is 4 (defined as <tt>#AI_LMW_MAX_WEIGHTS</tt> in
  /// config.h), but you can use the <tt>#AI_CONFIG_PP_LBW_MAX_WEIGHTS</tt> importer
  /// property to supply your own limit to the post processing step.
  ///
  /// If you intend to perform the skinning in hardware, this post processing
  /// step might be of interest to you.
  static const int aiProcess_LimitBoneWeights = 512;

  /// <hr>Validates the imported scene data structure.
  /// This makes sure that all indices are valid, all animations and
  /// bones are linked correctly, all material references are correct .. etc.
  ///
  /// It is recommended that you capture Assimp's log output if you use this flag,
  /// so you can easily find out what's wrong if a file fails the
  /// validation. The validator is quite strict and will find *all*
  /// inconsistencies in the data structure... It is recommended that plugin
  /// developers use it to debug their loaders. There are two types of
  /// validation failures:
  /// <ul>
  /// <li>Error: There's something wrong with the imported data. Further
  /// postprocessing is not possible and the data is not usable at all.
  /// The import fails. #Importer::GetErrorString() or #aiGetErrorString()
  /// carry the error message around.</li>
  /// <li>Warning: There are some minor issues (e.g. 1000000 animation
  /// keyframes with the same time), but further postprocessing and use
  /// of the data structure is still safe. Warning details are written
  /// to the log file, <tt>#AI_SCENE_FLAGS_VALIDATION_WARNING</tt> is set
  /// in #aiScene::mFlags</li>
  /// </ul>
  ///
  /// This post-processing step is not time-consuming. Its use is not
  /// compulsory, but recommended.
  static const int aiProcess_ValidateDataStructure = 1024;

  /// <hr>Reorders triangles for better vertex cache locality.
  ///
  /// The step tries to improve the ACMR (average post-transform vertex cache
  /// miss ratio) for all meshes. The implementation runs in O(n) and is
  /// roughly based on the 'tipsify' algorithm (see <a href="
  /// http://www.cs.princeton.edu/gfx/pubs/Sander_2007_%3ETR/tipsy.pdf">this
  /// paper</a>).
  ///
  /// If you intend to render huge models in hardware, this step might
  /// be of interest to you. The <tt>#AI_CONFIG_PP_ICL_PTCACHE_SIZE</tt>
  /// importer property can be used to fine-tune the cache optimization.
  static const int aiProcess_ImproveCacheLocality = 2048;

  /// <hr>Searches for redundant/unreferenced materials and removes them.
  ///
  /// This is especially useful in combination with the
  /// #aiProcess_PreTransformVertices and #aiProcess_OptimizeMeshes flags.
  /// Both join small meshes with equal characteristics, but they can't do
  /// their work if two meshes have different materials. Because several
  /// material settings are lost during Assimp's import filters,
  /// (and because many exporters don't check for redundant materials), huge
  /// models often have materials which are are defined several times with
  /// exactly the same settings.
  ///
  /// Several material settings not contributing to the final appearance of
  /// a surface are ignored in all comparisons (e.g. the material name).
  /// So, if you're passing additional information through the
  /// content pipeline (probably using *magic* material names), don't
  /// specify this flag. Alternatively take a look at the
  /// <tt>#AI_CONFIG_PP_RRM_EXCLUDE_LIST</tt> importer property.
  static const int aiProcess_RemoveRedundantMaterials = 4096;

  /// <hr>This step tries to determine which meshes have normal vectors
  /// that are facing inwards and inverts them.
  ///
  /// The algorithm is simple but effective:
  /// the bounding box of all vertices + their normals is compared against
  /// the volume of the bounding box of all vertices without their normals.
  /// This works well for most objects, problems might occur with planar
  /// surfaces. However, the step tries to filter such cases.
  /// The step inverts all in-facing normals. Generally it is recommended
  /// to enable this step, although the result is not always correct.
  static const int aiProcess_FixInfacingNormals = 8192;

  /// <hr>This step splits meshes with more than one primitive type in
  /// homogeneous sub-meshes.
  ///
  /// The step is executed after the triangulation step. After the step
  /// returns, just one bit is set in aiMesh::mPrimitiveTypes. This is
  /// especially useful for real-time rendering where point and line
  /// primitives are often ignored or rendered separately.
  /// You can use the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to
  /// specify which primitive types you need. This can be used to easily
  /// exclude lines and points, which are rarely used, from the import.
  static const int aiProcess_SortByPType = 32768;

  /// <hr>This step searches all meshes for degenerate primitives and
  /// converts them to proper lines or points.
  ///
  /// A face is 'degenerate' if one or more of its points are identical.
  /// To have the degenerate stuff not only detected and collapsed but
  /// removed, try one of the following procedures:
  /// <br><b>1.</b> (if you support lines and points for rendering but don't
  /// want the degenerates)<br>
  /// <ul>
  /// <li>Specify the #aiProcess_FindDegenerates flag.
  /// </li>
  /// <li>Set the <tt>#AI_CONFIG_PP_FD_REMOVE</tt> importer property to
  /// 1. This will cause the step to remove degenerate triangles from the
  /// import as soon as they're detected. They won't pass any further
  /// pipeline steps.
  /// </li>
  /// </ul>
  /// <br><b>2.</b>(if you don't support lines and points at all)<br>
  /// <ul>
  /// <li>Specify the #aiProcess_FindDegenerates flag.
  /// </li>
  /// <li>Specify the #aiProcess_SortByPType flag. This moves line and
  /// point primitives to separate meshes.
  /// </li>
  /// <li>Set the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to
  /// @code aiPrimitiveType_POINTS | aiPrimitiveType_LINES
  /// @endcode to cause SortByPType to reject point
  /// and line meshes from the scene.
  /// </li>
  /// </ul>
  ///
  /// This step also removes very small triangles with a surface area smaller
  /// than 10^-6. If you rely on having these small triangles, or notice holes
  /// in your model, set the property <tt>#AI_CONFIG_PP_FD_CHECKAREA</tt> to
  /// false.
  /// @note Degenerate polygons are not necessarily evil and that's why
  /// they're not removed by default. There are several file formats which
  /// don't support lines or points, and some exporters bypass the
  /// format specification and write them as degenerate triangles instead.
  static const int aiProcess_FindDegenerates = 65536;

  /// <hr>This step searches all meshes for invalid data, such as zeroed
  /// normal vectors or invalid UV coords and removes/fixes them. This is
  /// intended to get rid of some common exporter errors.
  ///
  /// This is especially useful for normals. If they are invalid, and
  /// the step recognizes this, they will be removed and can later
  /// be recomputed, i.e. by the #aiProcess_GenSmoothNormals flag.<br>
  /// The step will also remove meshes that are infinitely small and reduce
  /// animation tracks consisting of hundreds if redundant keys to a single
  /// key. The <tt>AI_CONFIG_PP_FID_ANIM_ACCURACY</tt> config property decides
  /// the accuracy of the check for duplicate animation tracks.
  static const int aiProcess_FindInvalidData = 131072;

  /// <hr>This step converts non-UV mappings (such as spherical or
  /// cylindrical mapping) to proper texture coordinate channels.
  ///
  /// Most applications will support UV mapping only, so you will
  /// probably want to specify this step in every case. Note that Assimp is not
  /// always able to match the original mapping implementation of the
  /// 3D app which produced a model perfectly. It's always better to let the
  /// modelling app compute the UV channels - 3ds max, Maya, Blender,
  /// LightWave, and Modo do this for example.
  ///
  /// @note If this step is not requested, you'll need to process the
  /// <tt>#AI_MATKEY_MAPPING</tt> material property in order to display all assets
  /// properly.
  static const int aiProcess_GenUVCoords = 262144;

  /// <hr>This step applies per-texture UV transformations and bakes
  /// them into stand-alone vtexture coordinate channels.
  ///
  /// UV transformations are specified per-texture - see the
  /// <tt>#AI_MATKEY_UVTRANSFORM</tt> material key for more information.
  /// This step processes all textures with
  /// transformed input UV coordinates and generates a new (pre-transformed) UV channel
  /// which replaces the old channel. Most applications won't support UV
  /// transformations, so you will probably want to specify this step.
  ///
  /// @note UV transformations are usually implemented in real-time apps by
  /// transforming texture coordinates at vertex shader stage with a 3x3
  /// (homogenous) transformation matrix.
  static const int aiProcess_TransformUVCoords = 524288;

  /// <hr>This step searches for duplicate meshes and replaces them
  /// with references to the first mesh.
  ///
  /// This step takes a while, so don't use it if speed is a concern.
  /// Its main purpose is to workaround the fact that many export
  /// file formats don't support instanced meshes, so exporters need to
  /// duplicate meshes. This step removes the duplicates again. Please
  /// note that Assimp does not currently support per-node material
  /// assignment to meshes, which means that identical meshes with
  /// different materials are currently *not* joined, although this is
  /// planned for future versions.
  static const int aiProcess_FindInstances = 1048576;

  /// <hr>A post-processing step to reduce the number of meshes.
  ///
  /// This will, in fact, reduce the number of draw calls.
  ///
  /// This is a very effective optimization and is recommended to be used
  /// together with #aiProcess_OptimizeGraph, if possible. The flag is fully
  /// compatible with both #aiProcess_SplitLargeMeshes and #aiProcess_SortByPType.
  static const int aiProcess_OptimizeMeshes = 2097152;

  /// <hr>A post-processing step to optimize the scene hierarchy.
  ///
  /// Nodes without animations, bones, lights or cameras assigned are
  /// collapsed and joined.
  ///
  /// Node names can be lost during this step. If you use special 'tag nodes'
  /// to pass additional information through your content pipeline, use the
  /// <tt>#AI_CONFIG_PP_OG_EXCLUDE_LIST</tt> importer property to specify a
  /// list of node names you want to be kept. Nodes matching one of the names
  /// in this list won't be touched or modified.
  ///
  /// Use this flag with caution. Most simple files will be collapsed to a
  /// single node, so complex hierarchies are usually completely lost. This is not
  /// useful for editor environments, but probably a very effective
  /// optimization if you just want to get the model data, convert it to your
  /// own format, and render it as fast as possible.
  ///
  /// This flag is designed to be used with #aiProcess_OptimizeMeshes for best
  /// results.
  ///
  /// @note 'Crappy' scenes with thousands of extremely small meshes packed
  /// in deeply nested nodes exist for almost all file formats.
  /// #aiProcess_OptimizeMeshes in combination with #aiProcess_OptimizeGraph
  /// usually fixes them all and makes them renderable.
  static const int aiProcess_OptimizeGraph = 4194304;

  /// <hr>This step flips all UV coordinates along the y-axis and adjusts
  /// material settings and bitangents accordingly.
  ///
  /// <b>Output UV coordinate system:</b>
  /// @code
  /// 0y|0y ---------- 1x|0y
  /// |                 |
  /// |                 |
  /// |                 |
  /// 0x|1y ---------- 1x|1y
  /// @endcode
  ///
  /// You'll probably want to consider this flag if you use Direct3D for
  /// rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this
  /// setting and bundles all conversions typically required for D3D-based
  /// applications.
  static const int aiProcess_FlipUVs = 8388608;

  /// <hr>This step adjusts the output face winding order to be CW.
  ///
  /// The default face winding order is counter clockwise (CCW).
  ///
  /// <b>Output face order:</b>
  /// @code
  /// x2
  ///
  /// x0
  /// x1
  /// @endcode
  static const int aiProcess_FlipWindingOrder = 16777216;

  /// <hr>This step splits meshes with many bones into sub-meshes so that each
  /// sub-mesh has fewer or as many bones as a given limit.
  static const int aiProcess_SplitByBoneCount = 33554432;

  /// <hr>This step removes bones losslessly or according to some threshold.
  ///
  /// In some cases (i.e. formats that require it) exporters are forced to
  /// assign dummy bone weights to otherwise static meshes assigned to
  /// animated meshes. Full, weight-based skinning is expensive while
  /// animating nodes is extremely cheap, so this step is offered to clean up
  /// the data in that regard.
  ///
  /// Use <tt>#AI_CONFIG_PP_DB_THRESHOLD</tt> to control this.
  /// Use <tt>#AI_CONFIG_PP_DB_ALL_OR_NONE</tt> if you want bones removed if and
  /// only if all bones within the scene qualify for removal.
  static const int aiProcess_Debone = 67108864;

  /// <hr>This step will perform a global scale of the model.
  ///
  /// Some importers are providing a mechanism to define a scaling unit for the
  /// model. This post processing step can be used to do so. You need to get the
  /// global scaling from your importer settings like in FBX. Use the flag
  /// AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY from the global property table to configure this.
  ///
  /// Use <tt>#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</tt> to setup the global scaling factor.
  static const int aiProcess_GlobalScale = 134217728;

  /// <hr>A postprocessing step to embed of textures.
  ///
  /// This will remove external data dependencies for textures.
  /// If a texture's file does not exist at the specified path
  /// (due, for instance, to an absolute path generated on another system),
  /// it will check if a file with the same name exists at the root folder
  /// of the imported model. And if so, it uses that.
  static const int aiProcess_EmbedTextures = 268435456;
  static const int aiProcess_ForceGenNormals = 536870912;

  /// <hr>Drops normals for all faces of all meshes.
  ///
  /// This is ignored if no normals are present.
  /// Face normals are shared between all points of a single face,
  /// so a single point can have multiple normals, which
  /// forces the library to duplicate vertices in some cases.
  /// #aiProcess_JoinIdenticalVertices is *senseless* then.
  /// This process gives sense back to aiProcess_JoinIdenticalVertices
  static const int aiProcess_DropNormals = 1073741824;

  ///
  static const int aiProcess_GenBoundingBoxes = -2147483648;
}

/// @brief Helper structure to represent a texel in a ARGB8888 format
///
/// Used by aiTexture.
@ffi.Packed(1)
class aiTexel extends ffi.Struct {
  @ffi.Uint8()
  external int b;

  @ffi.Uint8()
  external int g;

  @ffi.Uint8()
  external int r;

  @ffi.Uint8()
  external int a;
}

/// Helper structure to describe an embedded texture
///
/// Normally textures are contained in external files but some file formats embed
/// them directly in the model file. There are two types of embedded textures:
/// 1. Uncompressed textures. The color data is given in an uncompressed format.
/// 2. Compressed textures stored in a file format like png or jpg. The raw file
/// bytes are given so the application must utilize an image decoder (e.g. DevIL) to
/// get access to the actual color data.
///
/// Embedded textures are referenced from materials using strings like "*0", "*1", etc.
/// as the texture paths (a single asterisk character followed by the
/// zero-based index of the texture in the aiScene::mTextures array).
class aiTexture extends ffi.Struct {
  /// Width of the texture, in pixels
  ///
  /// If mHeight is zero the texture is compressed in a format
  /// like JPEG. In this case mWidth specifies the size of the
  /// memory area pcData is pointing to, in bytes.
  @ffi.Uint32()
  external int mWidth;

  /// Height of the texture, in pixels
  ///
  /// If this value is zero, pcData points to an compressed texture
  /// in any format (e.g. JPEG).
  @ffi.Uint32()
  external int mHeight;

  @ffi.Array.multi([9])
  external ffi.Array<ffi.Int8> achFormatHint;

  /// Data of the texture.
  ///
  /// Points to an array of mWidth * mHeight aiTexel's.
  /// The format of the texture data is always ARGB8888 to
  /// make the implementation for user of the library as easy
  /// as possible. If mHeight = 0 this is a pointer to a memory
  /// buffer of size mWidth containing the compressed texture
  /// data. Good luck, have fun!
  external ffi.Pointer<aiTexel> pcData;

  /// Texture original filename
  ///
  /// Used to get the texture reference
  external aiString mFilename;
}

class aiAABB extends ffi.Struct {
  external aiVector3D mMin;

  external aiVector3D mMax;
}

/// @brief A single face in a mesh, referring to multiple vertices.
///
/// If mNumIndices is 3, we call the face 'triangle', for mNumIndices > 3
/// it's called 'polygon' (hey, that's just a definition!).
/// <br>
/// aiMesh::mPrimitiveTypes can be queried to quickly examine which types of
/// primitive are actually present in a mesh. The #aiProcess_SortByPType flag
/// executes a special post-processing algorithm which splits meshes with
/// *different* primitive types mixed up (e.g. lines and triangles) in several
/// 'clean' submeshes. Furthermore there is a configuration option (
/// #AI_CONFIG_PP_SBP_REMOVE) to force #aiProcess_SortByPType to remove
/// specific kinds of primitives from the imported scene, completely and forever.
/// In many cases you'll probably want to set this setting to
/// @code
/// aiPrimitiveType_LINE|aiPrimitiveType_POINT
/// @endcode
/// Together with the #aiProcess_Triangulate flag you can then be sure that
/// #aiFace::mNumIndices is always 3.
/// @note Take a look at the @link data Data Structures page @endlink for
/// more information on the layout and winding order of a face.
class aiFace extends ffi.Struct {
  /// ! Number of indices defining this face.
  /// ! The maximum value for this member is #AI_MAX_FACE_INDICES.
  @ffi.Uint32()
  external int mNumIndices;

  /// ! Pointer to the indices array. Size of the array is given in numIndices.
  external ffi.Pointer<ffi.Uint32> mIndices;
}

/// @brief A single influence of a bone on a vertex.
class aiVertexWeight extends ffi.Struct {
  /// ! Index of the vertex which is influenced by the bone.
  @ffi.Uint32()
  external int mVertexId;

  /// ! The strength of the influence in the range (0...1).
  /// ! The influence from all bones at one vertex amounts to 1.
  @ffi.Float()
  external double mWeight;
}

/// @brief A single bone of a mesh.
///
/// A bone has a name by which it can be found in the frame hierarchy and by
/// which it can be addressed by animations. In addition it has a number of
/// influences on vertices, and a matrix relating the mesh position to the
/// position of the bone at the time of binding.
class aiBone extends ffi.Struct {
  /// ! The name of the bone.
  external aiString mName;

  /// ! The number of vertices affected by this bone.
  /// ! The maximum value for this member is #AI_MAX_BONE_WEIGHTS.
  @ffi.Uint32()
  external int mNumWeights;

  /// ! The influence weights of this bone, by vertex index.
  external ffi.Pointer<aiVertexWeight> mWeights;

  /// Matrix that transforms from bone space to mesh space in bind pose.
  ///
  /// This matrix describes the position of the mesh
  /// in the local space of this bone when the skeleton was bound.
  /// Thus it can be used directly to determine a desired vertex position,
  /// given the world-space transform of the bone when animated,
  /// and the position of the vertex in mesh space.
  ///
  /// It is sometimes called an inverse-bind matrix,
  /// or inverse bind pose matrix.
  external aiMatrix4x4 mOffsetMatrix;
}

/// @brief Enumerates the types of geometric primitives supported by Assimp.
///
/// @see aiFace Face data structure
/// @see aiProcess_SortByPType Per-primitive sorting of meshes
/// @see aiProcess_Triangulate Automatic triangulation
/// @see AI_CONFIG_PP_SBP_REMOVE Removal of specific primitive types.
abstract class aiPrimitiveType {
  /// A point primitive.
  ///
  /// This is just a single vertex in the virtual world,
  /// #aiFace contains just one index for such a primitive.
  static const int aiPrimitiveType_POINT = 1;

  /// A line primitive.
  ///
  /// This is a line defined through a start and an end position.
  /// #aiFace contains exactly two indices for such a primitive.
  static const int aiPrimitiveType_LINE = 2;

  /// A triangular primitive.
  ///
  /// A triangle consists of three indices.
  static const int aiPrimitiveType_TRIANGLE = 4;

  /// A higher-level polygon with more than 3 edges.
  ///
  /// A triangle is a polygon, but polygon in this context means
  /// "all polygons that are not triangles". The "Triangulate"-Step
  /// is provided for your convenience, it splits all polygons in
  /// triangles (which are much easier to handle).
  static const int aiPrimitiveType_POLYGON = 8;
  static const int _aiPrimitiveType_Force32Bit = 2147483647;
}

/// @brief An AnimMesh is an attachment to an #aiMesh stores per-vertex
/// animations for a particular frame.
///
/// You may think of an #aiAnimMesh as a `patch` for the host mesh, which
/// replaces only certain vertex data streams at a particular time.
/// Each mesh stores n attached attached meshes (#aiMesh::mAnimMeshes).
/// The actual relationship between the time line and anim meshes is
/// established by #aiMeshAnim, which references singular mesh attachments
/// by their ID and binds them to a time offset.
class aiAnimMesh extends ffi.Struct {
  /// Anim Mesh name
  external aiString mName;

  /// Replacement for aiMesh::mVertices. If this array is non-NULL,
  /// it *must* contain mNumVertices entries. The corresponding
  /// array in the host mesh must be non-NULL as well - animation
  /// meshes may neither add or nor remove vertex components (if
  /// a replacement array is NULL and the corresponding source
  /// array is not, the source data is taken instead)
  external ffi.Pointer<aiVector3D> mVertices;

  /// Replacement for aiMesh::mNormals.
  external ffi.Pointer<aiVector3D> mNormals;

  /// Replacement for aiMesh::mTangents.
  external ffi.Pointer<aiVector3D> mTangents;

  /// Replacement for aiMesh::mBitangents.
  external ffi.Pointer<aiVector3D> mBitangents;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiColor4D>> mColors;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiVector3D>> mTextureCoords;

  /// The number of vertices in the aiAnimMesh, and thus the length of all
  /// the member arrays.
  ///
  /// This has always the same value as the mNumVertices property in the
  /// corresponding aiMesh. It is duplicated here merely to make the length
  /// of the member arrays accessible even if the aiMesh is not known, e.g.
  /// from language bindings.
  @ffi.Uint32()
  external int mNumVertices;

  /// Weight of the AnimMesh.
  @ffi.Float()
  external double mWeight;
}

/// @brief Enumerates the methods of mesh morphing supported by Assimp.
abstract class aiMorphingMethod {
  /// Interpolation between morph targets
  static const int aiMorphingMethod_VERTEX_BLEND = 1;

  /// Normalized morphing between morph targets
  static const int aiMorphingMethod_MORPH_NORMALIZED = 2;

  /// Relative morphing between morph targets
  static const int aiMorphingMethod_MORPH_RELATIVE = 3;
  static const int _aiMorphingMethod_Force32Bit = 2147483647;
}

/// @brief A mesh represents a geometry or model with a single material.
///
/// It usually consists of a number of vertices and a series of primitives/faces
/// referencing the vertices. In addition there might be a series of bones, each
/// of them addressing a number of vertices with a certain weight. Vertex data
/// is presented in channels with each channel containing a single per-vertex
/// information such as a set of texture coords or a normal vector.
/// If a data pointer is non-null, the corresponding data stream is present.
/// From C++-programs you can also use the comfort functions Has*() to
/// test for the presence of various data streams.
///
/// A Mesh uses only a single material which is referenced by a material ID.
/// @note The mPositions member is usually not optional. However, vertex positions
/// *could* be missing if the #AI_SCENE_FLAGS_INCOMPLETE flag is set in
/// @code
/// aiScene::mFlags
/// @endcode
class aiMesh extends ffi.Struct {
  /// Bitwise combination of the members of the #aiPrimitiveType enum.
  /// This specifies which types of primitives are present in the mesh.
  /// The "SortByPrimitiveType"-Step can be used to make sure the
  /// output meshes consist of one primitive type each.
  @ffi.Uint32()
  external int mPrimitiveTypes;

  /// The number of vertices in this mesh.
  /// This is also the size of all of the per-vertex data arrays.
  /// The maximum value for this member is #AI_MAX_VERTICES.
  @ffi.Uint32()
  external int mNumVertices;

  /// The number of primitives (triangles, polygons, lines) in this  mesh.
  /// This is also the size of the mFaces array.
  /// The maximum value for this member is #AI_MAX_FACES.
  @ffi.Uint32()
  external int mNumFaces;

  /// Vertex positions.
  /// This array is always present in a mesh. The array is
  /// mNumVertices in size.
  external ffi.Pointer<aiVector3D> mVertices;

  /// Vertex normals.
  /// The array contains normalized vectors, NULL if not present.
  /// The array is mNumVertices in size. Normals are undefined for
  /// point and line primitives. A mesh consisting of points and
  /// lines only may not have normal vectors. Meshes with mixed
  /// primitive types (i.e. lines and triangles) may have normals,
  /// but the normals for vertices that are only referenced by
  /// point or line primitives are undefined and set to QNaN (WARN:
  /// qNaN compares to inequal to *everything*, even to qNaN itself.
  /// Using code like this to check whether a field is qnan is:
  /// @code
  /// #define IS_QNAN(f) (f != f)
  /// @endcode
  /// still dangerous because even 1.f == 1.f could evaluate to false! (
  /// remember the subtleties of IEEE754 artithmetics). Use stuff like
  /// @c fpclassify instead.
  /// @note Normal vectors computed by Assimp are always unit-length.
  /// However, this needn't apply for normals that have been taken
  /// directly from the model file.
  external ffi.Pointer<aiVector3D> mNormals;

  /// Vertex tangents.
  /// The tangent of a vertex points in the direction of the positive
  /// X texture axis. The array contains normalized vectors, NULL if
  /// not present. The array is mNumVertices in size. A mesh consisting
  /// of points and lines only may not have normal vectors. Meshes with
  /// mixed primitive types (i.e. lines and triangles) may have
  /// normals, but the normals for vertices that are only referenced by
  /// point or line primitives are undefined and set to qNaN.  See
  /// the #mNormals member for a detailed discussion of qNaNs.
  /// @note If the mesh contains tangents, it automatically also
  /// contains bitangents.
  external ffi.Pointer<aiVector3D> mTangents;

  /// Vertex bitangents.
  /// The bitangent of a vertex points in the direction of the positive
  /// Y texture axis. The array contains normalized vectors, NULL if not
  /// present. The array is mNumVertices in size.
  /// @note If the mesh contains tangents, it automatically also contains
  /// bitangents.
  external ffi.Pointer<aiVector3D> mBitangents;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiColor4D>> mColors;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<aiVector3D>> mTextureCoords;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint32> mNumUVComponents;

  /// The faces the mesh is constructed from.
  /// Each face refers to a number of vertices by their indices.
  /// This array is always present in a mesh, its size is given
  /// in mNumFaces. If the #AI_SCENE_FLAGS_NON_VERBOSE_FORMAT
  /// is NOT set each face references an unique set of vertices.
  external ffi.Pointer<aiFace> mFaces;

  /// The number of bones this mesh contains.
  /// Can be 0, in which case the mBones array is NULL.
  @ffi.Uint32()
  external int mNumBones;

  /// The bones of this mesh.
  /// A bone consists of a name by which it can be found in the
  /// frame hierarchy and a set of vertex weights.
  external ffi.Pointer<ffi.Pointer<aiBone>> mBones;

  /// The material used by this mesh.
  /// A mesh uses only a single material. If an imported model uses
  /// multiple materials, the import splits up the mesh. Use this value
  /// as index into the scene's material list.
  @ffi.Uint32()
  external int mMaterialIndex;

  /// Name of the mesh. Meshes can be named, but this is not a
  /// requirement and leaving this field empty is totally fine.
  /// There are mainly three uses for mesh names:
  /// - some formats name nodes and meshes independently.
  /// - importers tend to split meshes up to meet the
  /// one-material-per-mesh requirement. Assigning
  /// the same (dummy) name to each of the result meshes
  /// aids the caller at recovering the original mesh
  /// partitioning.
  /// - Vertex animations refer to meshes by their names.
  external aiString mName;

  /// The number of attachment meshes. Note! Currently only works with Collada loader.
  @ffi.Uint32()
  external int mNumAnimMeshes;

  /// Attachment meshes for this mesh, for vertex-based animation.
  /// Attachment meshes carry replacement data for some of the
  /// mesh'es vertex components (usually positions, normals).
  /// Note! Currently only works with Collada loader.
  external ffi.Pointer<ffi.Pointer<aiAnimMesh>> mAnimMeshes;

  /// Method of morphing when animeshes are specified.
  @ffi.Uint32()
  external int mMethod;

  ///
  external aiAABB mAABB;
}

/// Enumerates all supported types of light sources.
abstract class aiLightSourceType {
  static const int aiLightSource_UNDEFINED = 0;

  /// ! A directional light source has a well-defined direction
  /// ! but is infinitely far away. That's quite a good
  /// ! approximation for sun light.
  static const int aiLightSource_DIRECTIONAL = 1;

  /// ! A point light source has a well-defined position
  /// ! in space but no direction - it emits light in all
  /// ! directions. A normal bulb is a point light.
  static const int aiLightSource_POINT = 2;

  /// ! A spot light source emits light in a specific
  /// ! angle. It has a position and a direction it is pointing to.
  /// ! A good example for a spot light is a light spot in
  /// ! sport arenas.
  static const int aiLightSource_SPOT = 3;

  /// ! The generic light level of the world, including the bounces
  /// ! of all other light sources.
  /// ! Typically, there's at most one ambient light in a scene.
  /// ! This light type doesn't have a valid position, direction, or
  /// ! other properties, just a color.
  static const int aiLightSource_AMBIENT = 4;

  /// ! An area light is a rectangle with predefined size that uniformly
  /// ! emits light from one of its sides. The position is center of the
  /// ! rectangle and direction is its normal vector.
  static const int aiLightSource_AREA = 5;
  static const int _aiLightSource_Force32Bit = 2147483647;
}

/// Helper structure to describe a light source.
///
/// Assimp supports multiple sorts of light sources, including
/// directional, point and spot lights. All of them are defined with just
/// a single structure and distinguished by their parameters.
/// Note - some file formats (such as 3DS, ASE) export a "target point" -
/// the point a spot light is looking at (it can even be animated). Assimp
/// writes the target point as a subnode of a spotlights's main node,
/// called "<spotName>.Target". However, this is just additional information
/// then, the transformation tracks of the main node make the
/// spot light already point in the right direction.
class aiLight extends ffi.Struct {
  /// The name of the light source.
  ///
  /// There must be a node in the scenegraph with the same name.
  /// This node specifies the position of the light in the scene
  /// hierarchy and can be animated.
  external aiString mName;

  /// The type of the light source.
  ///
  /// aiLightSource_UNDEFINED is not a valid value for this member.
  @ffi.Int32()
  external int mType;

  /// Position of the light source in space. Relative to the
  /// transformation of the node corresponding to the light.
  ///
  /// The position is undefined for directional lights.
  external aiVector3D mPosition;

  /// Direction of the light source in space. Relative to the
  /// transformation of the node corresponding to the light.
  ///
  /// The direction is undefined for point lights. The vector
  /// may be normalized, but it needn't.
  external aiVector3D mDirection;

  /// Up direction of the light source in space. Relative to the
  /// transformation of the node corresponding to the light.
  ///
  /// The direction is undefined for point lights. The vector
  /// may be normalized, but it needn't.
  external aiVector3D mUp;

  /// Constant light attenuation factor.
  ///
  /// The intensity of the light source at a given distance 'd' from
  /// the light's position is
  /// @code
  /// Atten = 1/( att0 + att1 * d + att2 * d*d)
  /// @endcode
  /// This member corresponds to the att0 variable in the equation.
  /// Naturally undefined for directional lights.
  @ffi.Float()
  external double mAttenuationConstant;

  /// Linear light attenuation factor.
  ///
  /// The intensity of the light source at a given distance 'd' from
  /// the light's position is
  /// @code
  /// Atten = 1/( att0 + att1 * d + att2 * d*d)
  /// @endcode
  /// This member corresponds to the att1 variable in the equation.
  /// Naturally undefined for directional lights.
  @ffi.Float()
  external double mAttenuationLinear;

  /// Quadratic light attenuation factor.
  ///
  /// The intensity of the light source at a given distance 'd' from
  /// the light's position is
  /// @code
  /// Atten = 1/( att0 + att1 * d + att2 * d*d)
  /// @endcode
  /// This member corresponds to the att2 variable in the equation.
  /// Naturally undefined for directional lights.
  @ffi.Float()
  external double mAttenuationQuadratic;

  /// Diffuse color of the light source
  ///
  /// The diffuse light color is multiplied with the diffuse
  /// material color to obtain the final color that contributes
  /// to the diffuse shading term.
  external aiColor3D mColorDiffuse;

  /// Specular color of the light source
  ///
  /// The specular light color is multiplied with the specular
  /// material color to obtain the final color that contributes
  /// to the specular shading term.
  external aiColor3D mColorSpecular;

  /// Ambient color of the light source
  ///
  /// The ambient light color is multiplied with the ambient
  /// material color to obtain the final color that contributes
  /// to the ambient shading term. Most renderers will ignore
  /// this value it, is just a remaining of the fixed-function pipeline
  /// that is still supported by quite many file formats.
  external aiColor3D mColorAmbient;

  /// Inner angle of a spot light's light cone.
  ///
  /// The spot light has maximum influence on objects inside this
  /// angle. The angle is given in radians. It is 2PI for point
  /// lights and undefined for directional lights.
  @ffi.Float()
  external double mAngleInnerCone;

  /// Outer angle of a spot light's light cone.
  ///
  /// The spot light does not affect objects outside this angle.
  /// The angle is given in radians. It is 2PI for point lights and
  /// undefined for directional lights. The outer angle must be
  /// greater than or equal to the inner angle.
  /// It is assumed that the application uses a smooth
  /// interpolation between the inner and the outer cone of the
  /// spot light.
  @ffi.Float()
  external double mAngleOuterCone;

  /// Size of area light source.
  external aiVector2D mSize;
}

/// Helper structure to describe a virtual camera.
///
/// Cameras have a representation in the node graph and can be animated.
/// An important aspect is that the camera itself is also part of the
/// scene-graph. This means, any values such as the look-at vector are not
/// *absolute*, they're <b>relative</b> to the coordinate system defined
/// by the node which corresponds to the camera. This allows for camera
/// animations. For static cameras parameters like the 'look-at' or 'up' vectors
/// are usually specified directly in aiCamera, but beware, they could also
/// be encoded in the node transformation. The following (pseudo)code sample
/// shows how to do it: <br><br>
/// @code
/// // Get the camera matrix for a camera at a specific time
/// // if the node hierarchy for the camera does not contain
/// // at least one animated node this is a static computation
/// get-camera-matrix (node sceneRoot, camera cam) : matrix
/// {
/// node   cnd = find-node-for-camera(cam)
/// matrix cmt = identity()
///
/// // as usual - get the absolute camera transformation for this frame
/// for each node nd in hierarchy from sceneRoot to cnd
/// matrix cur
/// if (is-animated(nd))
/// cur = eval-animation(nd)
/// else cur = nd->mTransformation;
/// cmt = mult-matrices( cmt, cur )
/// end for
///
/// // now multiply with the camera's own local transform
/// cam = mult-matrices (cam, get-camera-matrix(cmt) )
/// }
/// @endcode
///
/// @note some file formats (such as 3DS, ASE) export a "target point" -
/// the point the camera is looking at (it can even be animated). Assimp
/// writes the target point as a subnode of the camera's main node,
/// called "<camName>.Target". However this is just additional information
/// then the transformation tracks of the camera main node make the
/// camera already look in the right direction.
class aiCamera extends ffi.Struct {
  /// The name of the camera.
  ///
  /// There must be a node in the scenegraph with the same name.
  /// This node specifies the position of the camera in the scene
  /// hierarchy and can be animated.
  external aiString mName;

  /// Position of the camera relative to the coordinate space
  /// defined by the corresponding node.
  ///
  /// The default value is 0|0|0.
  external aiVector3D mPosition;

  /// 'Up' - vector of the camera coordinate system relative to
  /// the coordinate space defined by the corresponding node.
  ///
  /// The 'right' vector of the camera coordinate system is
  /// the cross product of  the up and lookAt vectors.
  /// The default value is 0|1|0. The vector
  /// may be normalized, but it needn't.
  external aiVector3D mUp;

  /// 'LookAt' - vector of the camera coordinate system relative to
  /// the coordinate space defined by the corresponding node.
  ///
  /// This is the viewing direction of the user.
  /// The default value is 0|0|1. The vector
  /// may be normalized, but it needn't.
  external aiVector3D mLookAt;

  /// Half horizontal field of view angle, in radians.
  ///
  /// The field of view angle is the angle between the center
  /// line of the screen and the left or right border.
  /// The default value is 1/4PI.
  @ffi.Float()
  external double mHorizontalFOV;

  /// Distance of the near clipping plane from the camera.
  ///
  /// The value may not be 0.f (for arithmetic reasons to prevent
  /// a division through zero). The default value is 0.1f.
  @ffi.Float()
  external double mClipPlaneNear;

  /// Distance of the far clipping plane from the camera.
  ///
  /// The far clipping plane must, of course, be further away than the
  /// near clipping plane. The default value is 1000.f. The ratio
  /// between the near and the far plane should not be too
  /// large (between 1000-10000 should be ok) to avoid floating-point
  /// inaccuracies which could lead to z-fighting.
  @ffi.Float()
  external double mClipPlaneFar;

  /// Screen aspect ratio.
  ///
  /// This is the ration between the width and the height of the
  /// screen. Typical values are 4/3, 1/2 or 1/1. This value is
  /// 0 if the aspect ratio is not defined in the source file.
  /// 0 is also the default value.
  @ffi.Float()
  external double mAspect;
}

/// @brief Defines how the Nth texture of a specific type is combined with
/// the result of all previous layers.
///
/// Example (left: key, right: value): <br>
/// @code
/// DiffColor0     - gray
/// DiffTextureOp0 - aiTextureOpMultiply
/// DiffTexture0   - tex1.png
/// DiffTextureOp0 - aiTextureOpAdd
/// DiffTexture1   - tex2.png
/// @endcode
/// Written as equation, the final diffuse term for a specific pixel would be:
/// @code
/// diffFinal = DiffColor0 * sampleTex(DiffTexture0,UV0) +
/// sampleTex(DiffTexture1,UV0) * diffContrib;
/// @endcode
/// where 'diffContrib' is the intensity of the incoming light for that pixel.
abstract class aiTextureOp {
  /// T = T1 * T2
  static const int aiTextureOp_Multiply = 0;

  /// T = T1 + T2
  static const int aiTextureOp_Add = 1;

  /// T = T1 - T2
  static const int aiTextureOp_Subtract = 2;

  /// T = T1 / T2
  static const int aiTextureOp_Divide = 3;

  /// T = (T1 + T2) - (T1 * T2)
  static const int aiTextureOp_SmoothAdd = 4;

  /// T = T1 + (T2-0.5)
  static const int aiTextureOp_SignedAdd = 5;
  static const int _aiTextureOp_Force32Bit = 2147483647;
}

/// @brief Defines how UV coordinates outside the [0...1] range are handled.
///
/// Commonly referred to as 'wrapping mode'.
abstract class aiTextureMapMode {
  /// A texture coordinate u|v is translated to u%1|v%1
  static const int aiTextureMapMode_Wrap = 0;

  /// Texture coordinates outside [0...1]
  /// are clamped to the nearest valid value.
  static const int aiTextureMapMode_Clamp = 1;

  /// If the texture coordinates for a pixel are outside [0...1]
  /// the texture is not applied to that pixel
  static const int aiTextureMapMode_Decal = 3;

  /// A texture coordinate u|v becomes u%1|v%1 if (u-(u%1))%2 is zero and
  /// 1-(u%1)|1-(v%1) otherwise
  static const int aiTextureMapMode_Mirror = 2;
  static const int _aiTextureMapMode_Force32Bit = 2147483647;
}

/// @brief Defines how the mapping coords for a texture are generated.
///
/// Real-time applications typically require full UV coordinates, so the use of
/// the aiProcess_GenUVCoords step is highly recommended. It generates proper
/// UV channels for non-UV mapped objects, as long as an accurate description
/// how the mapping should look like (e.g spherical) is given.
/// See the #AI_MATKEY_MAPPING property for more details.
abstract class aiTextureMapping {
  /// The mapping coordinates are taken from an UV channel.
  ///
  /// The #AI_MATKEY_UVWSRC key specifies from which UV channel
  /// the texture coordinates are to be taken from (remember,
  /// meshes can have more than one UV channel).
  static const int aiTextureMapping_UV = 0;

  /// Spherical mapping
  static const int aiTextureMapping_SPHERE = 1;

  /// Cylindrical mapping
  static const int aiTextureMapping_CYLINDER = 2;

  /// Cubic mapping
  static const int aiTextureMapping_BOX = 3;

  /// Planar mapping
  static const int aiTextureMapping_PLANE = 4;

  /// Undefined mapping. Have fun.
  static const int aiTextureMapping_OTHER = 5;
  static const int _aiTextureMapping_Force32Bit = 2147483647;
}

/// @brief Defines the purpose of a texture
///
/// This is a very difficult topic. Different 3D packages support different
/// kinds of textures. For very common texture types, such as bumpmaps, the
/// rendering results depend on implementation details in the rendering
/// pipelines of these applications. Assimp loads all texture references from
/// the model file and tries to determine which of the predefined texture
/// types below is the best choice to match the original use of the texture
/// as closely as possible.<br>
///
/// In content pipelines you'll usually define how textures have to be handled,
/// and the artists working on models have to conform to this specification,
/// regardless which 3D tool they're using.
abstract class aiTextureType {
  /// Dummy value.
  ///
  /// No texture, but the value to be used as 'texture semantic'
  /// (#aiMaterialProperty::mSemantic) for all material properties
  /// *not* related to textures.
  static const int aiTextureType_NONE = 0;

  /// The texture is combined with the result of the diffuse
  /// lighting equation.
  static const int aiTextureType_DIFFUSE = 1;

  /// The texture is combined with the result of the specular
  /// lighting equation.
  static const int aiTextureType_SPECULAR = 2;

  /// The texture is combined with the result of the ambient
  /// lighting equation.
  static const int aiTextureType_AMBIENT = 3;

  /// The texture is added to the result of the lighting
  /// calculation. It isn't influenced by incoming light.
  static const int aiTextureType_EMISSIVE = 4;

  /// The texture is a height map.
  ///
  /// By convention, higher gray-scale values stand for
  /// higher elevations from the base height.
  static const int aiTextureType_HEIGHT = 5;

  /// The texture is a (tangent space) normal-map.
  ///
  /// Again, there are several conventions for tangent-space
  /// normal maps. Assimp does (intentionally) not
  /// distinguish here.
  static const int aiTextureType_NORMALS = 6;

  /// The texture defines the glossiness of the material.
  ///
  /// The glossiness is in fact the exponent of the specular
  /// (phong) lighting equation. Usually there is a conversion
  /// function defined to map the linear color values in the
  /// texture to a suitable exponent. Have fun.
  static const int aiTextureType_SHININESS = 7;

  /// The texture defines per-pixel opacity.
  ///
  /// Usually 'white' means opaque and 'black' means
  /// 'transparency'. Or quite the opposite. Have fun.
  static const int aiTextureType_OPACITY = 8;

  /// Displacement texture
  ///
  /// The exact purpose and format is application-dependent.
  /// Higher color values stand for higher vertex displacements.
  static const int aiTextureType_DISPLACEMENT = 9;

  /// Lightmap texture (aka Ambient Occlusion)
  ///
  /// Both 'Lightmaps' and dedicated 'ambient occlusion maps' are
  /// covered by this material property. The texture contains a
  /// scaling value for the final color value of a pixel. Its
  /// intensity is not affected by incoming light.
  static const int aiTextureType_LIGHTMAP = 10;

  /// Reflection texture
  ///
  /// Contains the color of a perfect mirror reflection.
  /// Rarely used, almost never for real-time applications.
  static const int aiTextureType_REFLECTION = 11;

  /// PBR Materials
  /// PBR definitions from maya and other modelling packages now use this standard.
  /// This was originally introduced around 2012.
  /// Support for this is in game engines like Godot, Unreal or Unity3D.
  /// Modelling packages which use this are very common now.
  static const int aiTextureType_BASE_COLOR = 12;
  static const int aiTextureType_NORMAL_CAMERA = 13;
  static const int aiTextureType_EMISSION_COLOR = 14;
  static const int aiTextureType_METALNESS = 15;
  static const int aiTextureType_DIFFUSE_ROUGHNESS = 16;
  static const int aiTextureType_AMBIENT_OCCLUSION = 17;

  /// Unknown texture
  ///
  /// A texture reference that does not match any of the definitions
  /// above is considered to be 'unknown'. It is still imported,
  /// but is excluded from any further post-processing.
  static const int aiTextureType_UNKNOWN = 18;
  static const int _aiTextureType_Force32Bit = 2147483647;
}

/// @brief Defines all shading models supported by the library
///
/// The list of shading modes has been taken from Blender.
/// See Blender documentation for more information. The API does
/// not distinguish between "specular" and "diffuse" shaders (thus the
/// specular term for diffuse shading models like Oren-Nayar remains
/// undefined). <br>
/// Again, this value is just a hint. Assimp tries to select the shader whose
/// most common implementation matches the original rendering results of the
/// 3D modeller which wrote a particular model as closely as possible.
abstract class aiShadingMode {
  /// Flat shading. Shading is done on per-face base,
  /// diffuse only. Also known as 'faceted shading'.
  static const int aiShadingMode_Flat = 1;

  /// Simple Gouraud shading.
  static const int aiShadingMode_Gouraud = 2;

  /// Phong-Shading -
  static const int aiShadingMode_Phong = 3;

  /// Phong-Blinn-Shading
  static const int aiShadingMode_Blinn = 4;

  /// Toon-Shading per pixel
  ///
  /// Also known as 'comic' shader.
  static const int aiShadingMode_Toon = 5;

  /// OrenNayar-Shading per pixel
  ///
  /// Extension to standard Lambertian shading, taking the
  /// roughness of the material into account
  static const int aiShadingMode_OrenNayar = 6;

  /// Minnaert-Shading per pixel
  ///
  /// Extension to standard Lambertian shading, taking the
  /// "darkness" of the material into account
  static const int aiShadingMode_Minnaert = 7;

  /// CookTorrance-Shading per pixel
  ///
  /// Special shader for metallic surfaces.
  static const int aiShadingMode_CookTorrance = 8;

  /// No shading at all. Constant light influence of 1.0.
  static const int aiShadingMode_NoShading = 9;

  /// Fresnel shading
  static const int aiShadingMode_Fresnel = 10;
  static const int _aiShadingMode_Force32Bit = 2147483647;
}

/// @brief Defines some mixed flags for a particular texture.
///
/// Usually you'll instruct your cg artists how textures have to look like ...
/// and how they will be processed in your application. However, if you use
/// Assimp for completely generic loading purposes you might also need to
/// process these flags in order to display as many 'unknown' 3D models as
/// possible correctly.
///
/// This corresponds to the #AI_MATKEY_TEXFLAGS property.
abstract class aiTextureFlags {
  /// The texture's color values have to be inverted (component-wise 1-n)
  static const int aiTextureFlags_Invert = 1;

  /// Explicit request to the application to process the alpha channel
  /// of the texture.
  ///
  /// Mutually exclusive with #aiTextureFlags_IgnoreAlpha. These
  /// flags are set if the library can say for sure that the alpha
  /// channel is used/is not used. If the model format does not
  /// define this, it is left to the application to decide whether
  /// the texture alpha channel - if any - is evaluated or not.
  static const int aiTextureFlags_UseAlpha = 2;

  /// Explicit request to the application to ignore the alpha channel
  /// of the texture.
  ///
  /// Mutually exclusive with #aiTextureFlags_UseAlpha.
  static const int aiTextureFlags_IgnoreAlpha = 4;
  static const int _aiTextureFlags_Force32Bit = 2147483647;
}

/// @brief Defines alpha-blend flags.
///
/// If you're familiar with OpenGL or D3D, these flags aren't new to you.
/// They define *how* the final color value of a pixel is computed, basing
/// on the previous color at that pixel and the new color value from the
/// material.
/// The blend formula is:
/// @code
/// SourceColor * SourceBlend + DestColor * DestBlend
/// @endcode
/// where DestColor is the previous color in the framebuffer at this
/// position and SourceColor is the material color before the transparency
/// calculation.<br>
/// This corresponds to the #AI_MATKEY_BLEND_FUNC property.
abstract class aiBlendMode {
  /// Formula:
  /// @code
  /// SourceColor*SourceAlpha + DestColor*(1-SourceAlpha)
  /// @endcode
  static const int aiBlendMode_Default = 0;

  /// Additive blending
  ///
  /// Formula:
  /// @code
  /// SourceColor*1 + DestColor*1
  /// @endcode
  static const int aiBlendMode_Additive = 1;
  static const int _aiBlendMode_Force32Bit = 2147483647;
}

/// @brief Defines how an UV channel is transformed.
///
/// This is just a helper structure for the #AI_MATKEY_UVTRANSFORM key.
/// See its documentation for more details.
///
/// Typically you'll want to build a matrix of this information. However,
/// we keep separate scaling/translation/rotation values to make it
/// easier to process and optimize UV transformations internally.
class aiUVTransform extends ffi.Struct {
  /// Translation on the u and v axes.
  ///
  /// The default value is (0|0).
  external aiVector2D mTranslation;

  /// Scaling on the u and v axes.
  ///
  /// The default value is (1|1).
  external aiVector2D mScaling;

  /// Rotation - in counter-clockwise direction.
  ///
  /// The rotation angle is specified in radians. The
  /// rotation center is 0.5f|0.5f. The default value
  /// 0.f.
  @ffi.Float()
  external double mRotation;
}

/// @brief A very primitive RTTI system for the contents of material
/// properties.
abstract class aiPropertyTypeInfo {
  /// Array of single-precision (32 Bit) floats
  ///
  /// It is possible to use aiGetMaterialInteger[Array]() (or the C++-API
  /// aiMaterial::Get()) to query properties stored in floating-point format.
  /// The material system performs the type conversion automatically.
  static const int aiPTI_Float = 1;

  /// Array of double-precision (64 Bit) floats
  ///
  /// It is possible to use aiGetMaterialInteger[Array]() (or the C++-API
  /// aiMaterial::Get()) to query properties stored in floating-point format.
  /// The material system performs the type conversion automatically.
  static const int aiPTI_Double = 2;

  /// The material property is an aiString.
  ///
  /// Arrays of strings aren't possible, aiGetMaterialString() (or the
  /// C++-API aiMaterial::Get()) *must* be used to query a string property.
  static const int aiPTI_String = 3;

  /// Array of (32 Bit) integers
  ///
  /// It is possible to use aiGetMaterialFloat[Array]() (or the C++-API
  /// aiMaterial::Get()) to query properties stored in integer format.
  /// The material system performs the type conversion automatically.
  static const int aiPTI_Integer = 4;

  /// Simple binary buffer, content undefined. Not convertible to anything.
  static const int aiPTI_Buffer = 5;
  static const int _aiPTI_Force32Bit = 2147483647;
}

/// @brief Data structure for a single material property
///
/// As an user, you'll probably never need to deal with this data structure.
/// Just use the provided aiGetMaterialXXX() or aiMaterial::Get() family
/// of functions to query material properties easily. Processing them
/// manually is faster, but it is not the recommended way. It isn't worth
/// the effort. <br>
/// Material property names follow a simple scheme:
/// @code
/// $<name>
/// ?<name>
/// A public property, there must be corresponding AI_MATKEY_XXX define
/// 2nd: Public, but ignored by the #aiProcess_RemoveRedundantMaterials
/// post-processing step.
/// ~<name>
/// A temporary property for internal use.
/// @endcode
/// @see aiMaterial
class aiMaterialProperty extends ffi.Struct {
  /// Specifies the name of the property (key)
  /// Keys are generally case insensitive.
  external aiString mKey;

  /// Textures: Specifies their exact usage semantic.
  /// For non-texture properties, this member is always 0
  /// (or, better-said, #aiTextureType_NONE).
  @ffi.Uint32()
  external int mSemantic;

  /// Textures: Specifies the index of the texture.
  /// For non-texture properties, this member is always 0.
  @ffi.Uint32()
  external int mIndex;

  /// Size of the buffer mData is pointing to, in bytes.
  /// This value may not be 0.
  @ffi.Uint32()
  external int mDataLength;

  /// Type information for the property.
  ///
  /// Defines the data layout inside the data buffer. This is used
  /// by the library internally to perform debug checks and to
  /// utilize proper type conversions.
  /// (It's probably a hacky solution, but it works.)
  @ffi.Int32()
  external int mType;

  /// Binary buffer to hold the property's value.
  /// The size of the buffer is always mDataLength.
  external ffi.Pointer<ffi.Int8> mData;
}

class aiMaterial extends ffi.Struct {
  /// List of all material properties loaded.
  external ffi.Pointer<ffi.Pointer<aiMaterialProperty>> mProperties;

  /// Number of properties in the data base
  @ffi.Uint32()
  external int mNumProperties;

  /// Storage allocated
  @ffi.Uint32()
  external int mNumAllocated;
}

/// A time-value pair specifying a certain 3D vector for the given time.
class aiVectorKey extends ffi.Struct {
  /// The time of this key
  @ffi.Double()
  external double mTime;

  /// The value of this key
  external aiVector3D mValue;
}

/// A time-value pair specifying a rotation for the given time.
/// Rotations are expressed with quaternions.
class aiQuatKey extends ffi.Struct {
  /// The time of this key
  @ffi.Double()
  external double mTime;

  /// The value of this key
  external aiQuaternion mValue;
}

/// Binds a anim-mesh to a specific point in time.
class aiMeshKey extends ffi.Struct {
  /// The time of this key
  @ffi.Double()
  external double mTime;

  /// Index into the aiMesh::mAnimMeshes array of the
  /// mesh corresponding to the #aiMeshAnim hosting this
  /// key frame. The referenced anim mesh is evaluated
  /// according to the rules defined in the docs for #aiAnimMesh.
  @ffi.Uint32()
  external int mValue;
}

/// Binds a morph anim mesh to a specific point in time.
class aiMeshMorphKey extends ffi.Struct {
  /// The time of this key
  @ffi.Double()
  external double mTime;

  /// The values and weights at the time of this key
  external ffi.Pointer<ffi.Uint32> mValues;

  external ffi.Pointer<ffi.Double> mWeights;

  /// The number of values and weights
  @ffi.Uint32()
  external int mNumValuesAndWeights;
}

/// Defines how an animation channel behaves outside the defined time
/// range. This corresponds to aiNodeAnim::mPreState and
/// aiNodeAnim::mPostState.
abstract class aiAnimBehaviour {
  /// The value from the default node transformation is taken
  static const int aiAnimBehaviour_DEFAULT = 0;

  /// The nearest key value is used without interpolation
  static const int aiAnimBehaviour_CONSTANT = 1;

  /// The value of the nearest two keys is linearly
  /// extrapolated for the current time value.
  static const int aiAnimBehaviour_LINEAR = 2;

  /// The animation is repeated.
  ///
  /// If the animation key go from n to m and the current
  /// time is t, use the value at (t-n) % (|m-n|).
  static const int aiAnimBehaviour_REPEAT = 3;
  static const int _aiAnimBehaviour_Force32Bit = 2147483647;
}

/// Describes the animation of a single node. The name specifies the
/// bone/node which is affected by this animation channel. The keyframes
/// are given in three separate series of values, one each for position,
/// rotation and scaling. The transformation matrix computed from these
/// values replaces the node's original transformation matrix at a
/// specific time.
/// This means all keys are absolute and not relative to the bone default pose.
/// The order in which the transformations are applied is
/// - as usual - scaling, rotation, translation.
///
/// @note All keys are returned in their correct, chronological order.
/// Duplicate keys don't pass the validation step. Most likely there
/// will be no negative time values, but they are not forbidden also ( so
/// implementations need to cope with them! )
class aiNodeAnim extends ffi.Struct {
  /// The name of the node affected by this animation. The node
  /// must exist and it must be unique.
  external aiString mNodeName;

  /// The number of position keys
  @ffi.Uint32()
  external int mNumPositionKeys;

  /// The position keys of this animation channel. Positions are
  /// specified as 3D vector. The array is mNumPositionKeys in size.
  ///
  /// If there are position keys, there will also be at least one
  /// scaling and one rotation key.
  external ffi.Pointer<aiVectorKey> mPositionKeys;

  /// The number of rotation keys
  @ffi.Uint32()
  external int mNumRotationKeys;

  /// The rotation keys of this animation channel. Rotations are
  /// given as quaternions,  which are 4D vectors. The array is
  /// mNumRotationKeys in size.
  ///
  /// If there are rotation keys, there will also be at least one
  /// scaling and one position key.
  external ffi.Pointer<aiQuatKey> mRotationKeys;

  /// The number of scaling keys
  @ffi.Uint32()
  external int mNumScalingKeys;

  /// The scaling keys of this animation channel. Scalings are
  /// specified as 3D vector. The array is mNumScalingKeys in size.
  ///
  /// If there are scaling keys, there will also be at least one
  /// position and one rotation key.
  external ffi.Pointer<aiVectorKey> mScalingKeys;

  /// Defines how the animation behaves before the first
  /// key is encountered.
  ///
  /// The default value is aiAnimBehaviour_DEFAULT (the original
  /// transformation matrix of the affected node is used).
  @ffi.Int32()
  external int mPreState;

  /// Defines how the animation behaves after the last
  /// key was processed.
  ///
  /// The default value is aiAnimBehaviour_DEFAULT (the original
  /// transformation matrix of the affected node is taken).
  @ffi.Int32()
  external int mPostState;
}

/// Describes vertex-based animations for a single mesh or a group of
/// meshes. Meshes carry the animation data for each frame in their
/// aiMesh::mAnimMeshes array. The purpose of aiMeshAnim is to
/// define keyframes linking each mesh attachment to a particular
/// point in time.
class aiMeshAnim extends ffi.Struct {
  /// Name of the mesh to be animated. An empty string is not allowed,
  /// animated meshes need to be named (not necessarily uniquely,
  /// the name can basically serve as wild-card to select a group
  /// of meshes with similar animation setup)
  external aiString mName;

  /// Size of the #mKeys array. Must be 1, at least.
  @ffi.Uint32()
  external int mNumKeys;

  /// Key frames of the animation. May not be NULL.
  external ffi.Pointer<aiMeshKey> mKeys;
}

/// Describes a morphing animation of a given mesh.
class aiMeshMorphAnim extends ffi.Struct {
  /// Name of the mesh to be animated. An empty string is not allowed,
  /// animated meshes need to be named (not necessarily uniquely,
  /// the name can basically serve as wildcard to select a group
  /// of meshes with similar animation setup)
  external aiString mName;

  /// Size of the #mKeys array. Must be 1, at least.
  @ffi.Uint32()
  external int mNumKeys;

  /// Key frames of the animation. May not be NULL.
  external ffi.Pointer<aiMeshMorphKey> mKeys;
}

/// An animation consists of key-frame data for a number of nodes. For
/// each node affected by the animation a separate series of data is given.
class aiAnimation extends ffi.Struct {
  /// The name of the animation. If the modeling package this data was
  /// exported from does support only a single animation channel, this
  /// name is usually empty (length is zero).
  external aiString mName;

  /// Duration of the animation in ticks.
  @ffi.Double()
  external double mDuration;

  /// Ticks per second. 0 if not specified in the imported file
  @ffi.Double()
  external double mTicksPerSecond;

  /// The number of bone animation channels. Each channel affects
  /// a single node.
  @ffi.Uint32()
  external int mNumChannels;

  /// The node animation channels. Each channel affects a single node.
  /// The array is mNumChannels in size.
  external ffi.Pointer<ffi.Pointer<aiNodeAnim>> mChannels;

  /// The number of mesh animation channels. Each channel affects
  /// a single mesh and defines vertex-based animation.
  @ffi.Uint32()
  external int mNumMeshChannels;

  /// The mesh animation channels. Each channel affects a single mesh.
  /// The array is mNumMeshChannels in size.
  external ffi.Pointer<ffi.Pointer<aiMeshAnim>> mMeshChannels;

  /// The number of mesh animation channels. Each channel affects
  /// a single mesh and defines morphing animation.
  @ffi.Uint32()
  external int mNumMorphMeshChannels;

  /// The morph mesh animation channels. Each channel affects a single mesh.
  /// The array is mNumMorphMeshChannels in size.
  external ffi.Pointer<ffi.Pointer<aiMeshMorphAnim>> mMorphMeshChannels;
}

/// Enum used to distinguish data types
abstract class aiMetadataType {
  static const int AI_BOOL = 0;
  static const int AI_INT32 = 1;
  static const int AI_UINT64 = 2;
  static const int AI_FLOAT = 3;
  static const int AI_DOUBLE = 4;
  static const int AI_AISTRING = 5;
  static const int AI_AIVECTOR3D = 6;
  static const int AI_META_MAX = 7;
  static const int FORCE_32BIT = 2147483647;
}

/// Metadata entry
///
/// The type field uniquely identifies the underlying type of the data field
class aiMetadataEntry extends ffi.Struct {
  @ffi.Int32()
  external int mType;

  external ffi.Pointer<ffi.Void> mData;
}

/// Container for holding metadata.
///
/// Metadata is a key-value store using string keys and values.
class aiMetadata extends ffi.Struct {
  /// Length of the mKeys and mValues arrays, respectively
  @ffi.Uint32()
  external int mNumProperties;

  /// Arrays of keys, may not be NULL. Entries in this array may not be NULL as well.
  external ffi.Pointer<aiString> mKeys;

  /// Arrays of values, may not be NULL. Entries in this array may be NULL if the
  /// corresponding property key has no assigned value.
  external ffi.Pointer<aiMetadataEntry> mValues;
}

/// A node in the imported hierarchy.
///
/// Each node has name, a parent node (except for the root node),
/// a transformation relative to its parent and possibly several child nodes.
/// Simple file formats don't support hierarchical structures - for these formats
/// the imported scene does consist of only a single root node without children.
class aiNode extends ffi.Struct {
  /// The name of the node.
  ///
  /// The name might be empty (length of zero) but all nodes which
  /// need to be referenced by either bones or animations are named.
  /// Multiple nodes may have the same name, except for nodes which are referenced
  /// by bones (see #aiBone and #aiMesh::mBones). Their names *must* be unique.
  ///
  /// Cameras and lights reference a specific node by name - if there
  /// are multiple nodes with this name, they are assigned to each of them.
  /// <br>
  /// There are no limitations with regard to the characters contained in
  /// the name string as it is usually taken directly from the source file.
  ///
  /// Implementations should be able to handle tokens such as whitespace, tabs,
  /// line feeds, quotation marks, ampersands etc.
  ///
  /// Sometimes assimp introduces new nodes not present in the source file
  /// into the hierarchy (usually out of necessity because sometimes the
  /// source hierarchy format is simply not compatible). Their names are
  /// surrounded by @verbatim <> @endverbatim e.g.
  /// @verbatim<DummyRootNode> @endverbatim.
  external aiString mName;

  /// The transformation relative to the node's parent.
  external aiMatrix4x4 mTransformation;

  /// Parent node. NULL if this node is the root node.
  external ffi.Pointer<aiNode> mParent;

  /// The number of child nodes of this node.
  @ffi.Uint32()
  external int mNumChildren;

  /// The child nodes of this node. NULL if mNumChildren is 0.
  external ffi.Pointer<ffi.Pointer<aiNode>> mChildren;

  /// The number of meshes of this node.
  @ffi.Uint32()
  external int mNumMeshes;

  /// The meshes of this node. Each entry is an index into the
  /// mesh list of the #aiScene.
  external ffi.Pointer<ffi.Uint32> mMeshes;

  /// Metadata associated with this node or NULL if there is no metadata.
  /// Whether any metadata is generated depends on the source file format. See the
  /// @link importer_notes @endlink page for more information on every source file
  /// format. Importers that don't document any metadata don't write any.
  external ffi.Pointer<aiMetadata> mMetaData;
}

const String AI_CONFIG_GLOB_MEASURE_TIME = 'GLOB_MEASURE_TIME';

const String AI_CONFIG_IMPORT_NO_SKELETON_MESHES = 'IMPORT_NO_SKELETON_MESHES';

const String AI_CONFIG_PP_SBBC_MAX_BONES = 'PP_SBBC_MAX_BONES';

const int AI_SBBC_DEFAULT_MAX_BONES = 60;

const String AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE = 'PP_CT_MAX_SMOOTHING_ANGLE';

const String AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX =
    'PP_CT_TEXTURE_CHANNEL_INDEX';

const String AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE =
    'PP_GSN_MAX_SMOOTHING_ANGLE';

const String AI_CONFIG_IMPORT_MDL_COLORMAP = 'IMPORT_MDL_COLORMAP';

const String AI_CONFIG_PP_RRM_EXCLUDE_LIST = 'PP_RRM_EXCLUDE_LIST';

const String AI_CONFIG_PP_PTV_KEEP_HIERARCHY = 'PP_PTV_KEEP_HIERARCHY';

const String AI_CONFIG_PP_PTV_NORMALIZE = 'PP_PTV_NORMALIZE';

const String AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION =
    'PP_PTV_ADD_ROOT_TRANSFORMATION';

const String AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION =
    'PP_PTV_ROOT_TRANSFORMATION';

const String AI_CONFIG_PP_FD_REMOVE = 'PP_FD_REMOVE';

const String AI_CONFIG_PP_FD_CHECKAREA = 'PP_FD_CHECKAREA';

const String AI_CONFIG_PP_OG_EXCLUDE_LIST = 'PP_OG_EXCLUDE_LIST';

const String AI_CONFIG_PP_SLM_TRIANGLE_LIMIT = 'PP_SLM_TRIANGLE_LIMIT';

const int AI_SLM_DEFAULT_MAX_TRIANGLES = 1000000;

const String AI_CONFIG_PP_SLM_VERTEX_LIMIT = 'PP_SLM_VERTEX_LIMIT';

const int AI_SLM_DEFAULT_MAX_VERTICES = 1000000;

const String AI_CONFIG_PP_LBW_MAX_WEIGHTS = 'PP_LBW_MAX_WEIGHTS';

const int AI_LMW_MAX_WEIGHTS = 4;

const String AI_CONFIG_PP_DB_THRESHOLD = 'PP_DB_THRESHOLD';

const double AI_DEBONE_THRESHOLD = 1.0;

const String AI_CONFIG_PP_DB_ALL_OR_NONE = 'PP_DB_ALL_OR_NONE';

const String AI_CONFIG_PP_ICL_PTCACHE_SIZE = 'PP_ICL_PTCACHE_SIZE';

const String AI_CONFIG_PP_RVC_FLAGS = 'PP_RVC_FLAGS';

const String AI_CONFIG_PP_SBP_REMOVE = 'PP_SBP_REMOVE';

const String AI_CONFIG_PP_FID_ANIM_ACCURACY = 'PP_FID_ANIM_ACCURACY';

const String AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS =
    'PP_FID_IGNORE_TEXTURECOORDS';

const int AI_UVTRAFO_SCALING = 1;

const int AI_UVTRAFO_ROTATION = 2;

const int AI_UVTRAFO_TRANSLATION = 4;

const int AI_UVTRAFO_ALL = 7;

const String AI_CONFIG_PP_TUV_EVALUATE = 'PP_TUV_EVALUATE';

const String AI_CONFIG_FAVOUR_SPEED = 'FAVOUR_SPEED';

const String AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS =
    'IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS';

const String AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS =
    'IMPORT_FBX_READ_ALL_MATERIALS';

const String AI_CONFIG_IMPORT_FBX_READ_MATERIALS = 'IMPORT_FBX_READ_MATERIALS';

const String AI_CONFIG_IMPORT_FBX_READ_TEXTURES = 'IMPORT_FBX_READ_TEXTURES';

const String AI_CONFIG_IMPORT_FBX_READ_CAMERAS = 'IMPORT_FBX_READ_CAMERAS';

const String AI_CONFIG_IMPORT_FBX_READ_LIGHTS = 'IMPORT_FBX_READ_LIGHTS';

const String AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS =
    'IMPORT_FBX_READ_ANIMATIONS';

const String AI_CONFIG_IMPORT_FBX_STRICT_MODE = 'IMPORT_FBX_STRICT_MODE';

const String AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS =
    'IMPORT_FBX_PRESERVE_PIVOTS';

const String AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES =
    'IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES';

const String AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING =
    'AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING';

const String AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES =
    'AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES';

const String AI_CONFIG_FBX_CONVERT_TO_M = 'AI_CONFIG_FBX_CONVERT_TO_M';

const String AI_CONFIG_IMPORT_GLOBAL_KEYFRAME = 'IMPORT_GLOBAL_KEYFRAME';

const String AI_CONFIG_IMPORT_MD3_KEYFRAME = 'IMPORT_MD3_KEYFRAME';

const String AI_CONFIG_IMPORT_MD2_KEYFRAME = 'IMPORT_MD2_KEYFRAME';

const String AI_CONFIG_IMPORT_MDL_KEYFRAME = 'IMPORT_MDL_KEYFRAME';

const String AI_CONFIG_IMPORT_MDC_KEYFRAME = 'IMPORT_MDC_KEYFRAME';

const String AI_CONFIG_IMPORT_SMD_KEYFRAME = 'IMPORT_SMD_KEYFRAME';

const String AI_CONFIG_IMPORT_UNREAL_KEYFRAME = 'IMPORT_UNREAL_KEYFRAME';

const String AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST =
    'IMPORT_SMD_LOAD_ANIMATION_LIST';

const String AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL = 'IMPORT_AC_SEPARATE_BFCULL';

const String AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION =
    'IMPORT_AC_EVAL_SUBDIVISION';

const String AI_CONFIG_IMPORT_UNREAL_HANDLE_FLAGS = 'UNREAL_HANDLE_FLAGS';

const String AI_CONFIG_IMPORT_TER_MAKE_UVS = 'IMPORT_TER_MAKE_UVS';

const String AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS =
    'IMPORT_ASE_RECONSTRUCT_NORMALS';

const String AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART =
    'IMPORT_MD3_HANDLE_MULTIPART';

const String AI_CONFIG_IMPORT_MD3_SKIN_NAME = 'IMPORT_MD3_SKIN_NAME';

const String AI_CONFIG_IMPORT_MD3_SHADER_SRC = 'IMPORT_MD3_SHADER_SRC';

const String AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY = 'IMPORT_LWO_ONE_LAYER_ONLY';

const String AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD =
    'IMPORT_MD5_NO_ANIM_AUTOLOAD';

const String AI_CONFIG_IMPORT_LWS_ANIM_START = 'IMPORT_LWS_ANIM_START';

const String AI_CONFIG_IMPORT_LWS_ANIM_END = 'IMPORT_LWS_ANIM_END';

const String AI_CONFIG_IMPORT_IRR_ANIM_FPS = 'IMPORT_IRR_ANIM_FPS';

const String AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE = 'IMPORT_OGRE_MATERIAL_FILE';

const String AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME =
    'IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME';

const String AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT =
    'AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT';

const String AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS =
    'IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS';

const String AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION =
    'IMPORT_IFC_CUSTOM_TRIANGULATION';

const String AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE =
    'IMPORT_IFC_SMOOTHING_ANGLE';

const double AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE = 10.0;

const String AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION =
    'IMPORT_IFC_CYLINDRICAL_TESSELLATION';

const int AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION = 32;

const String AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION =
    'IMPORT_COLLADA_IGNORE_UP_DIRECTION';

const String AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES =
    'IMPORT_COLLADA_USE_COLLADA_NAMES';

const String AI_CONFIG_EXPORT_XFILE_64BIT = 'EXPORT_XFILE_64BIT';

const String AI_CONFIG_EXPORT_POINT_CLOUDS = 'EXPORT_POINT_CLOUDS';

const String AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY = 'GLOBAL_SCALE_FACTOR';

const double AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT = 1.0;

const String AI_CONFIG_APP_SCALE_KEY = 'APP_SCALE_FACTOR';

const double AI_MATH_PI = 3.141592653589793;

const double AI_MATH_TWO_PI = 6.283185307179586;

const double AI_MATH_HALF_PI = 1.5707963267948966;

const double AI_MATH_PI_F = 3.1415927410125732;

const double AI_MATH_TWO_PI_F = 6.2831854820251465;

const double AI_MATH_HALF_PI_F = 1.5707963705062866;

const int AI_SUCCESS = 0;

const int AI_FAILURE = -1;

const int AI_OUTOFMEMORY = -3;

const int AI_FALSE = 0;

const int AI_TRUE = 1;

const String AI_EMBEDDED_TEXNAME_PREFIX = '*';

const int AI_MAX_FACE_INDICES = 32767;

const int AI_MAX_BONE_WEIGHTS = 2147483647;

const int AI_MAX_VERTICES = 2147483647;

const int AI_MAX_FACES = 2147483647;

const int AI_MAX_NUMBER_OF_COLOR_SETS = 8;

const int AI_MAX_NUMBER_OF_TEXTURECOORDS = 8;

const String AI_DEFAULT_MATERIAL_NAME = 'DefaultMaterial';

const int AI_TEXTURE_TYPE_MAX = 18;

const String AI_MATKEY_NAME = '?mat.name';

const String AI_MATKEY_TWOSIDED = '\$mat.twosided';

const String AI_MATKEY_SHADING_MODEL = '\$mat.shadingm';

const String AI_MATKEY_ENABLE_WIREFRAME = '\$mat.wireframe';

const String AI_MATKEY_BLEND_FUNC = '\$mat.blend';

const String AI_MATKEY_OPACITY = '\$mat.opacity';

const String AI_MATKEY_TRANSPARENCYFACTOR = '\$mat.transparencyfactor';

const String AI_MATKEY_BUMPSCALING = '\$mat.bumpscaling';

const String AI_MATKEY_SHININESS = '\$mat.shininess';

const String AI_MATKEY_REFLECTIVITY = '\$mat.reflectivity';

const String AI_MATKEY_SHININESS_STRENGTH = '\$mat.shinpercent';

const String AI_MATKEY_REFRACTI = '\$mat.refracti';

const String AI_MATKEY_COLOR_DIFFUSE = '\$clr.diffuse';

const String AI_MATKEY_COLOR_AMBIENT = '\$clr.ambient';

const String AI_MATKEY_COLOR_SPECULAR = '\$clr.specular';

const String AI_MATKEY_COLOR_EMISSIVE = '\$clr.emissive';

const String AI_MATKEY_COLOR_TRANSPARENT = '\$clr.transparent';

const String AI_MATKEY_COLOR_REFLECTIVE = '\$clr.reflective';

const String AI_MATKEY_GLOBAL_BACKGROUND_IMAGE = '?bg.global';

const String AI_MATKEY_GLOBAL_SHADERLANG = '?sh.lang';

const String AI_MATKEY_SHADER_VERTEX = '?sh.vs';

const String AI_MATKEY_SHADER_FRAGMENT = '?sh.fs';

const String AI_MATKEY_SHADER_GEO = '?sh.gs';

const String AI_MATKEY_SHADER_TESSELATION = '?sh.ts';

const String AI_MATKEY_SHADER_PRIMITIVE = '?sh.ps';

const String AI_MATKEY_SHADER_COMPUTE = '?sh.cs';

const int AI_SCENE_FLAGS_INCOMPLETE = 1;

const int AI_SCENE_FLAGS_VALIDATED = 2;

const int AI_SCENE_FLAGS_VALIDATION_WARNING = 4;

const int AI_SCENE_FLAGS_NON_VERBOSE_FORMAT = 8;

const int AI_SCENE_FLAGS_TERRAIN = 16;

const int AI_SCENE_FLAGS_ALLOW_SHARED = 32;

typedef _c_aiGetExportFormatCount = ffi.Uint64 Function();

typedef _dart_aiGetExportFormatCount = int Function();

typedef _c_aiGetExportFormatDescription = ffi.Pointer<aiExportFormatDesc>
    Function(
  ffi.Uint64 pIndex,
);

typedef _dart_aiGetExportFormatDescription = ffi.Pointer<aiExportFormatDesc>
    Function(
  int pIndex,
);

typedef _c_aiReleaseExportFormatDescription = ffi.Void Function(
  ffi.Pointer<aiExportFormatDesc> desc,
);

typedef _dart_aiReleaseExportFormatDescription = void Function(
  ffi.Pointer<aiExportFormatDesc> desc,
);

typedef _c_aiCopyScene = ffi.Void Function(
  ffi.Pointer<aiScene> pIn,
  ffi.Pointer<ffi.Pointer<aiScene>> pOut,
);

typedef _dart_aiCopyScene = void Function(
  ffi.Pointer<aiScene> pIn,
  ffi.Pointer<ffi.Pointer<aiScene>> pOut,
);

typedef _c_aiFreeScene = ffi.Void Function(
  ffi.Pointer<aiScene> pIn,
);

typedef _dart_aiFreeScene = void Function(
  ffi.Pointer<aiScene> pIn,
);

typedef _c_aiExportScene = ffi.Int32 Function(
  ffi.Pointer<aiScene> pScene,
  ffi.Pointer<ffi.Int8> pFormatId,
  ffi.Pointer<ffi.Int8> pFileName,
  ffi.Uint32 pPreprocessing,
);

typedef _dart_aiExportScene = int Function(
  ffi.Pointer<aiScene> pScene,
  ffi.Pointer<ffi.Int8> pFormatId,
  ffi.Pointer<ffi.Int8> pFileName,
  int pPreprocessing,
);

typedef _c_aiExportSceneEx = ffi.Int32 Function(
  ffi.Pointer<aiScene> pScene,
  ffi.Pointer<ffi.Int8> pFormatId,
  ffi.Pointer<ffi.Int8> pFileName,
  ffi.Pointer<aiFileIO> pIO,
  ffi.Uint32 pPreprocessing,
);

typedef _dart_aiExportSceneEx = int Function(
  ffi.Pointer<aiScene> pScene,
  ffi.Pointer<ffi.Int8> pFormatId,
  ffi.Pointer<ffi.Int8> pFileName,
  ffi.Pointer<aiFileIO> pIO,
  int pPreprocessing,
);

typedef _c_aiExportSceneToBlob = ffi.Pointer<aiExportDataBlob> Function(
  ffi.Pointer<aiScene> pScene,
  ffi.Pointer<ffi.Int8> pFormatId,
  ffi.Uint32 pPreprocessing,
);

typedef _dart_aiExportSceneToBlob = ffi.Pointer<aiExportDataBlob> Function(
  ffi.Pointer<aiScene> pScene,
  ffi.Pointer<ffi.Int8> pFormatId,
  int pPreprocessing,
);

typedef _c_aiReleaseExportBlob = ffi.Void Function(
  ffi.Pointer<aiExportDataBlob> pData,
);

typedef _dart_aiReleaseExportBlob = void Function(
  ffi.Pointer<aiExportDataBlob> pData,
);

typedef _c_aiGetImporterDesc = ffi.Pointer<aiImporterDesc> Function(
  ffi.Pointer<ffi.Int8> extension_1,
);

typedef _dart_aiGetImporterDesc = ffi.Pointer<aiImporterDesc> Function(
  ffi.Pointer<ffi.Int8> extension_1,
);

typedef _c_aiImportFile = ffi.Pointer<aiScene> Function(
  ffi.Pointer<ffi.Int8> pFile,
  ffi.Uint32 pFlags,
);

typedef _dart_aiImportFile = ffi.Pointer<aiScene> Function(
  ffi.Pointer<ffi.Int8> pFile,
  int pFlags,
);

typedef _c_aiImportFileEx = ffi.Pointer<aiScene> Function(
  ffi.Pointer<ffi.Int8> pFile,
  ffi.Uint32 pFlags,
  ffi.Pointer<aiFileIO> pFS,
);

typedef _dart_aiImportFileEx = ffi.Pointer<aiScene> Function(
  ffi.Pointer<ffi.Int8> pFile,
  int pFlags,
  ffi.Pointer<aiFileIO> pFS,
);

typedef _c_aiImportFileExWithProperties = ffi.Pointer<aiScene> Function(
  ffi.Pointer<ffi.Int8> pFile,
  ffi.Uint32 pFlags,
  ffi.Pointer<aiFileIO> pFS,
  ffi.Pointer<aiPropertyStore> pProps,
);

typedef _dart_aiImportFileExWithProperties = ffi.Pointer<aiScene> Function(
  ffi.Pointer<ffi.Int8> pFile,
  int pFlags,
  ffi.Pointer<aiFileIO> pFS,
  ffi.Pointer<aiPropertyStore> pProps,
);

typedef _c_aiImportFileFromMemory = ffi.Pointer<aiScene> Function(
  ffi.Pointer<ffi.Int8> pBuffer,
  ffi.Uint32 pLength,
  ffi.Uint32 pFlags,
  ffi.Pointer<ffi.Int8> pHint,
);

typedef _dart_aiImportFileFromMemory = ffi.Pointer<aiScene> Function(
  ffi.Pointer<ffi.Int8> pBuffer,
  int pLength,
  int pFlags,
  ffi.Pointer<ffi.Int8> pHint,
);

typedef _c_aiImportFileFromMemoryWithProperties = ffi.Pointer<aiScene> Function(
  ffi.Pointer<ffi.Int8> pBuffer,
  ffi.Uint32 pLength,
  ffi.Uint32 pFlags,
  ffi.Pointer<ffi.Int8> pHint,
  ffi.Pointer<aiPropertyStore> pProps,
);

typedef _dart_aiImportFileFromMemoryWithProperties = ffi.Pointer<aiScene>
    Function(
  ffi.Pointer<ffi.Int8> pBuffer,
  int pLength,
  int pFlags,
  ffi.Pointer<ffi.Int8> pHint,
  ffi.Pointer<aiPropertyStore> pProps,
);

typedef _c_aiApplyPostProcessing = ffi.Pointer<aiScene> Function(
  ffi.Pointer<aiScene> pScene,
  ffi.Uint32 pFlags,
);

typedef _dart_aiApplyPostProcessing = ffi.Pointer<aiScene> Function(
  ffi.Pointer<aiScene> pScene,
  int pFlags,
);

typedef _c_aiGetPredefinedLogStream = aiLogStream Function(
  ffi.Int32 pStreams,
  ffi.Pointer<ffi.Int8> file,
);

typedef _dart_aiGetPredefinedLogStream = aiLogStream Function(
  int pStreams,
  ffi.Pointer<ffi.Int8> file,
);

typedef _c_aiAttachLogStream = ffi.Void Function(
  ffi.Pointer<aiLogStream> stream,
);

typedef _dart_aiAttachLogStream = void Function(
  ffi.Pointer<aiLogStream> stream,
);

typedef _c_aiEnableVerboseLogging = ffi.Void Function(
  ffi.Int32 d,
);

typedef _dart_aiEnableVerboseLogging = void Function(
  int d,
);

typedef _c_aiDetachLogStream = ffi.Int32 Function(
  ffi.Pointer<aiLogStream> stream,
);

typedef _dart_aiDetachLogStream = int Function(
  ffi.Pointer<aiLogStream> stream,
);

typedef _c_aiDetachAllLogStreams = ffi.Void Function();

typedef _dart_aiDetachAllLogStreams = void Function();

typedef _c_aiReleaseImport = ffi.Void Function(
  ffi.Pointer<aiScene> pScene,
);

typedef _dart_aiReleaseImport = void Function(
  ffi.Pointer<aiScene> pScene,
);

typedef _c_aiGetErrorString = ffi.Pointer<ffi.Int8> Function();

typedef _dart_aiGetErrorString = ffi.Pointer<ffi.Int8> Function();

typedef _c_aiIsExtensionSupported = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> szExtension,
);

typedef _dart_aiIsExtensionSupported = int Function(
  ffi.Pointer<ffi.Int8> szExtension,
);

typedef _c_aiGetExtensionList = ffi.Void Function(
  ffi.Pointer<aiString> szOut,
);

typedef _dart_aiGetExtensionList = void Function(
  ffi.Pointer<aiString> szOut,
);

typedef _c_aiGetMemoryRequirements = ffi.Void Function(
  ffi.Pointer<aiScene> pIn,
  ffi.Pointer<aiMemoryInfo> in_1,
);

typedef _dart_aiGetMemoryRequirements = void Function(
  ffi.Pointer<aiScene> pIn,
  ffi.Pointer<aiMemoryInfo> in_1,
);

typedef _c_aiCreatePropertyStore = ffi.Pointer<aiPropertyStore> Function();

typedef _dart_aiCreatePropertyStore = ffi.Pointer<aiPropertyStore> Function();

typedef _c_aiReleasePropertyStore = ffi.Void Function(
  ffi.Pointer<aiPropertyStore> p,
);

typedef _dart_aiReleasePropertyStore = void Function(
  ffi.Pointer<aiPropertyStore> p,
);

typedef _c_aiSetImportPropertyInteger = ffi.Void Function(
  ffi.Pointer<aiPropertyStore> store,
  ffi.Pointer<ffi.Int8> szName,
  ffi.Int32 value,
);

typedef _dart_aiSetImportPropertyInteger = void Function(
  ffi.Pointer<aiPropertyStore> store,
  ffi.Pointer<ffi.Int8> szName,
  int value,
);

typedef _c_aiSetImportPropertyFloat = ffi.Void Function(
  ffi.Pointer<aiPropertyStore> store,
  ffi.Pointer<ffi.Int8> szName,
  ffi.Float value,
);

typedef _dart_aiSetImportPropertyFloat = void Function(
  ffi.Pointer<aiPropertyStore> store,
  ffi.Pointer<ffi.Int8> szName,
  double value,
);

typedef _c_aiSetImportPropertyString = ffi.Void Function(
  ffi.Pointer<aiPropertyStore> store,
  ffi.Pointer<ffi.Int8> szName,
  ffi.Pointer<aiString> st,
);

typedef _dart_aiSetImportPropertyString = void Function(
  ffi.Pointer<aiPropertyStore> store,
  ffi.Pointer<ffi.Int8> szName,
  ffi.Pointer<aiString> st,
);

typedef _c_aiSetImportPropertyMatrix = ffi.Void Function(
  ffi.Pointer<aiPropertyStore> store,
  ffi.Pointer<ffi.Int8> szName,
  ffi.Pointer<aiMatrix4x4> mat,
);

typedef _dart_aiSetImportPropertyMatrix = void Function(
  ffi.Pointer<aiPropertyStore> store,
  ffi.Pointer<ffi.Int8> szName,
  ffi.Pointer<aiMatrix4x4> mat,
);

typedef _c_aiCreateQuaternionFromMatrix = ffi.Void Function(
  ffi.Pointer<aiQuaternion> quat,
  ffi.Pointer<aiMatrix3x3> mat,
);

typedef _dart_aiCreateQuaternionFromMatrix = void Function(
  ffi.Pointer<aiQuaternion> quat,
  ffi.Pointer<aiMatrix3x3> mat,
);

typedef _c_aiDecomposeMatrix = ffi.Void Function(
  ffi.Pointer<aiMatrix4x4> mat,
  ffi.Pointer<aiVector3D> scaling,
  ffi.Pointer<aiQuaternion> rotation,
  ffi.Pointer<aiVector3D> position,
);

typedef _dart_aiDecomposeMatrix = void Function(
  ffi.Pointer<aiMatrix4x4> mat,
  ffi.Pointer<aiVector3D> scaling,
  ffi.Pointer<aiQuaternion> rotation,
  ffi.Pointer<aiVector3D> position,
);

typedef _c_aiTransposeMatrix4 = ffi.Void Function(
  ffi.Pointer<aiMatrix4x4> mat,
);

typedef _dart_aiTransposeMatrix4 = void Function(
  ffi.Pointer<aiMatrix4x4> mat,
);

typedef _c_aiTransposeMatrix3 = ffi.Void Function(
  ffi.Pointer<aiMatrix3x3> mat,
);

typedef _dart_aiTransposeMatrix3 = void Function(
  ffi.Pointer<aiMatrix3x3> mat,
);

typedef _c_aiTransformVecByMatrix3 = ffi.Void Function(
  ffi.Pointer<aiVector3D> vec,
  ffi.Pointer<aiMatrix3x3> mat,
);

typedef _dart_aiTransformVecByMatrix3 = void Function(
  ffi.Pointer<aiVector3D> vec,
  ffi.Pointer<aiMatrix3x3> mat,
);

typedef _c_aiTransformVecByMatrix4 = ffi.Void Function(
  ffi.Pointer<aiVector3D> vec,
  ffi.Pointer<aiMatrix4x4> mat,
);

typedef _dart_aiTransformVecByMatrix4 = void Function(
  ffi.Pointer<aiVector3D> vec,
  ffi.Pointer<aiMatrix4x4> mat,
);

typedef _c_aiMultiplyMatrix4 = ffi.Void Function(
  ffi.Pointer<aiMatrix4x4> dst,
  ffi.Pointer<aiMatrix4x4> src,
);

typedef _dart_aiMultiplyMatrix4 = void Function(
  ffi.Pointer<aiMatrix4x4> dst,
  ffi.Pointer<aiMatrix4x4> src,
);

typedef _c_aiMultiplyMatrix3 = ffi.Void Function(
  ffi.Pointer<aiMatrix3x3> dst,
  ffi.Pointer<aiMatrix3x3> src,
);

typedef _dart_aiMultiplyMatrix3 = void Function(
  ffi.Pointer<aiMatrix3x3> dst,
  ffi.Pointer<aiMatrix3x3> src,
);

typedef _c_aiIdentityMatrix3 = ffi.Void Function(
  ffi.Pointer<aiMatrix3x3> mat,
);

typedef _dart_aiIdentityMatrix3 = void Function(
  ffi.Pointer<aiMatrix3x3> mat,
);

typedef _c_aiIdentityMatrix4 = ffi.Void Function(
  ffi.Pointer<aiMatrix4x4> mat,
);

typedef _dart_aiIdentityMatrix4 = void Function(
  ffi.Pointer<aiMatrix4x4> mat,
);

typedef _c_aiGetImportFormatCount = ffi.Uint64 Function();

typedef _dart_aiGetImportFormatCount = int Function();

typedef _c_aiGetImportFormatDescription = ffi.Pointer<aiImporterDesc> Function(
  ffi.Uint64 pIndex,
);

typedef _dart_aiGetImportFormatDescription = ffi.Pointer<aiImporterDesc>
    Function(
  int pIndex,
);

typedef _c_aiGetMaterialProperty = ffi.Int32 Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Pointer<ffi.Int8> pKey,
  ffi.Uint32 type,
  ffi.Uint32 index,
  ffi.Pointer<ffi.Pointer<aiMaterialProperty>> pPropOut,
);

typedef _dart_aiGetMaterialProperty = int Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Pointer<ffi.Int8> pKey,
  int type,
  int index,
  ffi.Pointer<ffi.Pointer<aiMaterialProperty>> pPropOut,
);

typedef _c_aiGetMaterialFloatArray = ffi.Int32 Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Pointer<ffi.Int8> pKey,
  ffi.Uint32 type,
  ffi.Uint32 index,
  ffi.Pointer<ffi.Float> pOut,
  ffi.Pointer<ffi.Uint32> pMax,
);

typedef _dart_aiGetMaterialFloatArray = int Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Pointer<ffi.Int8> pKey,
  int type,
  int index,
  ffi.Pointer<ffi.Float> pOut,
  ffi.Pointer<ffi.Uint32> pMax,
);

typedef _c_aiGetMaterialIntegerArray = ffi.Int32 Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Pointer<ffi.Int8> pKey,
  ffi.Uint32 type,
  ffi.Uint32 index,
  ffi.Pointer<ffi.Int32> pOut,
  ffi.Pointer<ffi.Uint32> pMax,
);

typedef _dart_aiGetMaterialIntegerArray = int Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Pointer<ffi.Int8> pKey,
  int type,
  int index,
  ffi.Pointer<ffi.Int32> pOut,
  ffi.Pointer<ffi.Uint32> pMax,
);

typedef _c_aiGetMaterialColor = ffi.Int32 Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Pointer<ffi.Int8> pKey,
  ffi.Uint32 type,
  ffi.Uint32 index,
  ffi.Pointer<aiColor4D> pOut,
);

typedef _dart_aiGetMaterialColor = int Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Pointer<ffi.Int8> pKey,
  int type,
  int index,
  ffi.Pointer<aiColor4D> pOut,
);

typedef _c_aiGetMaterialUVTransform = ffi.Int32 Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Pointer<ffi.Int8> pKey,
  ffi.Uint32 type,
  ffi.Uint32 index,
  ffi.Pointer<aiUVTransform> pOut,
);

typedef _dart_aiGetMaterialUVTransform = int Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Pointer<ffi.Int8> pKey,
  int type,
  int index,
  ffi.Pointer<aiUVTransform> pOut,
);

typedef _c_aiGetMaterialString = ffi.Int32 Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Pointer<ffi.Int8> pKey,
  ffi.Uint32 type,
  ffi.Uint32 index,
  ffi.Pointer<aiString> pOut,
);

typedef _dart_aiGetMaterialString = int Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Pointer<ffi.Int8> pKey,
  int type,
  int index,
  ffi.Pointer<aiString> pOut,
);

typedef _c_aiGetMaterialTextureCount = ffi.Uint32 Function(
  ffi.Pointer<aiMaterial> pMat,
  ffi.Int32 type,
);

typedef _dart_aiGetMaterialTextureCount = int Function(
  ffi.Pointer<aiMaterial> pMat,
  int type,
);

typedef _c_aiGetMaterialTexture = ffi.Int32 Function(
  ffi.Pointer<aiMaterial> mat,
  ffi.Int32 type,
  ffi.Uint32 index,
  ffi.Pointer<aiString> path,
  ffi.Pointer<ffi.Int32> mapping,
  ffi.Pointer<ffi.Uint32> uvindex,
  ffi.Pointer<ffi.Float> blend,
  ffi.Pointer<ffi.Int32> op,
  ffi.Pointer<ffi.Int32> mapmode,
  ffi.Pointer<ffi.Uint32> flags,
);

typedef _dart_aiGetMaterialTexture = int Function(
  ffi.Pointer<aiMaterial> mat,
  int type,
  int index,
  ffi.Pointer<aiString> path,
  ffi.Pointer<ffi.Int32> mapping,
  ffi.Pointer<ffi.Uint32> uvindex,
  ffi.Pointer<ffi.Float> blend,
  ffi.Pointer<ffi.Int32> op,
  ffi.Pointer<ffi.Int32> mapmode,
  ffi.Pointer<ffi.Uint32> flags,
);

typedef _c_aiGetLegalString = ffi.Pointer<ffi.Int8> Function();

typedef _dart_aiGetLegalString = ffi.Pointer<ffi.Int8> Function();

typedef _c_aiGetVersionMinor = ffi.Uint32 Function();

typedef _dart_aiGetVersionMinor = int Function();

typedef _c_aiGetVersionMajor = ffi.Uint32 Function();

typedef _dart_aiGetVersionMajor = int Function();

typedef _c_aiGetVersionRevision = ffi.Uint32 Function();

typedef _dart_aiGetVersionRevision = int Function();

typedef _c_aiGetBranchName = ffi.Pointer<ffi.Int8> Function();

typedef _dart_aiGetBranchName = ffi.Pointer<ffi.Int8> Function();

typedef _c_aiGetCompileFlags = ffi.Uint32 Function();

typedef _dart_aiGetCompileFlags = int Function();

typedef aiFileReadProc = ffi.Uint64 Function(
  ffi.Pointer<aiFile>,
  ffi.Pointer<ffi.Int8>,
  ffi.Uint64,
  ffi.Uint64,
);

typedef aiFileWriteProc = ffi.Uint64 Function(
  ffi.Pointer<aiFile>,
  ffi.Pointer<ffi.Int8>,
  ffi.Uint64,
  ffi.Uint64,
);

typedef aiFileTellProc = ffi.Uint64 Function(
  ffi.Pointer<aiFile>,
);

typedef aiFileSeek = ffi.Int32 Function(
  ffi.Pointer<aiFile>,
  ffi.Uint64,
  ffi.Int32,
);

typedef aiFileFlushProc = ffi.Void Function(
  ffi.Pointer<aiFile>,
);

typedef aiLogStreamCallback = ffi.Void Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
);
